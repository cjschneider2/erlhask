module 'beam_flatten' ['module'/2,
		       'module_info'/0,
		       'module_info'/1]
    attributes []
'module'/2 =
    %% Line 27
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <{Mod,Exp,Attr,Fs,Lc},_X_Opt> when 'true' ->
	      let <_cor7> =
		  %% Line 28
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor4) ->
				case _cor4 of
				  <[F|_cor3]> when 'true' ->
				      let <_cor5> =
					  apply 'function'/1
					      (F)
				      in  let <_cor6> =
					      apply 'lc$^0'/1
						  (_cor3)
					  in  ( [_cor5|_cor6]
						-| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_670> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor4})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (Fs)
		    -| ['list_comprehension'] )
	      in  %% Line 28
		  {'ok',{Mod,Exp,Attr,_cor7,Lc}}
	  ( <_cor9,_cor8> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor1,_cor0})
		  -| [{'function_name',{'module',2}}] )
	    -| ['compiler_generated'] )
	end
'function'/1 =
    %% Line 30
    fun (_cor0) ->
	case _cor0 of
	  <{'function',Name,Arity,CLabel,Is0}> when 'true' ->
	      let <Is1> =
		  %% Line 31
		  apply 'block'/1
		      (Is0)
	      in  let <Is> =
		      %% Line 115
		      apply 'opt_1'/2
			  (Is1, [])
		  in  %% Line 33
		      {'function',Name,Arity,CLabel,Is}
	  ( <_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor0})
		  -| [{'function_name',{'function',1}}] )
	    -| ['compiler_generated'] )
	end
'block'/1 =
    %% Line 35
    fun (_cor0) ->
	%% Line 36
	apply 'block'/2
	    (_cor0, [])
'block'/2 =
    %% Line 38
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[{'block',Is0}|Is1],Acc> when 'true' ->
	      let <_cor2> =
		  apply 'norm_block'/2
		      (Is0, _cor0)
	      in  apply 'block'/2
		      (Is1, _cor2)
	  %% Line 39
	  <[I|Is],Acc> when 'true' ->
	      apply 'block'/2
		  (Is, [I|_cor0])
	  %% Line 40
	  <[],Acc> when 'true' ->
	      call 'lists':'reverse'
		  (_cor0)
	  ( <_cor4,_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor1,_cor0})
		  -| [{'function_name',{'block',2}}] )
	    -| ['compiler_generated'] )
	end
'norm_block'/2 =
    %% Line 42
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[{'set',[],[],{'alloc',R,Alloc}}|Is],Acc0> when 'true' ->
	      let <_1003> =
		  %% Line 91
		  case <_cor0,Alloc> of
		    <[I = {'bs_put',_cor4,_cor5,_cor6}|_1977],_51> when 'true' ->
			%% Line 94
			apply 'insert_alloc_1'/3
			    (_1977, Alloc, [I|[]])
		    %% Line 95
		    <_cor7,_cor8> when 'true' ->
			'impossible'
		  end
	      in  %% Line 43
		  case _1003 of
		    %% Line 44
		    <'impossible'> when 'true' ->
			let <_cor2> =
			    %% Line 45
			    apply 'norm_allocate'/2
				(Alloc, R)
			in  let <_cor3> =
				%% Line 45
				call 'lists':'reverse'
				    (_cor2, _cor0)
			    in  %% Line 45
				apply 'norm_block'/2
				    (Is, _cor3)
		    %% Line 46
		    <Acc> when 'true' ->
			%% Line 47
			apply 'norm_block'/2
			    (Is, _1003)
		  end
	  %% Line 49
	  <[I|Is],Acc> when 'true' ->
	      let <_cor5> =
		  apply 'norm'/1
		      (I)
	      in  apply 'norm_block'/2
		      (Is, [_cor5|_cor0])
	  %% Line 50
	  <[],Acc> when 'true' ->
	      _cor0
	  ( <_cor7,_cor6> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor1,_cor0})
		  -| [{'function_name',{'norm_block',2}}] )
	    -| ['compiler_generated'] )
	end
'norm'/1 =
    %% Line 52
    fun (_cor0) ->
	case _cor0 of
	  <{'set',[D|[]],As,{'bif',N,F}}> when 'true' ->
	      {'bif',N,F,As,D}
	  %% Line 53
	  <{'set',[D|[]],As,{'alloc',R,{'gc_bif',N,F}}}> when 'true' ->
	      {'gc_bif',N,F,R,As,D}
	  %% Line 54
	  <{'set',[D|[]],[],'init'}> when 'true' ->
	      {'init',D}
	  %% Line 55
	  <{'set',[D|[]],[S|[]],'move'}> when 'true' ->
	      {'move',S,D}
	  %% Line 56
	  <{'set',[D|[]],[S|[]],'fmove'}> when 'true' ->
	      {'fmove',S,D}
	  %% Line 57
	  <{'set',[D|[]],[S|[]],'fconv'}> when 'true' ->
	      {'fconv',S,D}
	  %% Line 58
	  <{'set',[D|[]],[S1|[S2|[]]],'put_list'}> when 'true' ->
	      {'put_list',S1,S2,D}
	  %% Line 59
	  <{'set',[D|[]],[],{'put_tuple',A}}> when 'true' ->
	      {'put_tuple',A,D}
	  %% Line 60
	  <{'set',[],[S|[]],'put'}> when 'true' ->
	      {'put',S}
	  %% Line 61
	  <{'set',[D|[]],[S|[]],{'get_tuple_element',I}}> when 'true' ->
	      {'get_tuple_element',S,I,D}
	  %% Line 62
	  <{'set',[],[S|[D|[]]],{'set_tuple_element',I}}> when 'true' ->
	      {'set_tuple_element',S,D,I}
	  %% Line 63
	  <{'set',[D1|[D2|[]]],[S|[]],'get_list'}> when 'true' ->
	      {'get_list',S,D1,D2}
	  %% Line 64
	  <{'set',[D|[]],[S|Puts],{'alloc',R,{'put_map',Op,F}}}> when 'true' ->
	      %% Line 65
	      {'put_map',F,Op,S,D,R,{'list',Puts}}
	  %% Line 66
	  <{'set',Gets,[S|[]],{'get_map_elements',F}}> when 'true' ->
	      %% Line 67
	      {'get_map_elements',F,S,{'list',Gets}}
	  %% Line 68
	  <{'set',[],[],'remove_message'}> when 'true' ->
	      'remove_message'
	  %% Line 69
	  <{'set',[],[],'fclearerror'}> when 'true' ->
	      'fclearerror'
	  %% Line 70
	  <{'set',[],[],'fcheckerror'}> when 'true' ->
	      {'fcheckerror',{'f',0}}
	  ( <_cor1> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor0})
		  -| [{'function_name',{'norm',1}}] )
	    -| ['compiler_generated'] )
	end
'norm_allocate'/2 =
    %% Line 72
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <{_X_Zero,'nostack',Nh,[]},Regs> when 'true' ->
	      %% Line 73
	      [{'test_heap',Nh,_cor0}|[]]
	  %% Line 74
	  <{'zero',0,Nh,[]},Regs> when 'true' ->
	      %% Line 75
	      apply 'norm_allocate'/2
		  ({'nozero',0,Nh,[]}, _cor0)
	  %% Line 76
	  <{'zero',Ns,0,[]},Regs> when 'true' ->
	      %% Line 77
	      [{'allocate_zero',Ns,_cor0}|[]]
	  %% Line 78
	  <{'zero',Ns,Nh,[]},Regs> when 'true' ->
	      %% Line 79
	      [{'allocate_heap_zero',Ns,Nh,_cor0}|[]]
	  %% Line 80
	  <{'nozero',Ns,0,Inits},Regs> when 'true' ->
	      %% Line 81
	      [{'allocate',Ns,_cor0}|Inits]
	  %% Line 82
	  <{'nozero',Ns,Nh,Inits},Regs> when 'true' ->
	      %% Line 83
	      [{'allocate_heap',Ns,Nh,_cor0}|Inits]
	  ( <_cor3,_cor2> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor1,_cor0})
		  -| [{'function_name',{'norm_allocate',2}}] )
	    -| ['compiler_generated'] )
	end
'insert_alloc_1'/3 =
    %% Line 97
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <[{Op = 'bs_init',Fail,Info0,Live,Ss,Dst}|Is],%% Line 98
							{_cor10,'nostack',Ws2,[]},Acc>
	      when %% Line 98
		call 'erlang':'is_integer'
		    (Live) ->
	      let <Ws1> =
		  %% Line 101
		  call 'erlang':'element'
		      (2, Info0)
	      in  let <Al> =
		      %% Line 102
		      call 'beam_utils':'combine_heap_needs'
			  (Ws1, Ws2)
		  in  let <Info> =
			  %% Line 103
			  call 'erlang':'setelement'
			      (2, Info0, Al)
		      in  let <I> =
			      %% Line 104
			      {Op,Fail,Info,Live,Ss,Dst}
			  in  %% Line 105
			      call 'lists':'reverse'
				  (_cor0, [I|Is])
	  %% Line 106
	  <[I = {'bs_put',_cor11,_cor12,_cor13}|Is],Alloc,Acc> when 'true' ->
	      %% Line 107
	      apply 'insert_alloc_1'/3
		  (Is, _cor1, [I|_cor0])
	  ( <_cor9,_cor8,_cor7> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor2,_cor1,_cor0})
		  -| [{'function_name',{'insert_alloc_1',3}}] )
	    -| ['compiler_generated'] )
	end
'opt_1'/2 =
    %% Line 117
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[I = {'move',_cor5,{'x',0}}|Is0],Acc0> when 'true' ->
	      let <_1534> =
		  %% Line 118
		  apply 'move_past_kill'/3
		      (Is0, I, _cor0)
	      in  %% Line 118
		  case _1534 of
		    %% Line 119
		    <'impossible'> when 'true' ->
			apply 'opt_1'/2
			    (Is0, [I|_cor0])
		    %% Line 120
		    <{Is,Acc}> when 'true' ->
			apply 'opt_1'/2
			    (Is, Acc)
		    ( <_cor2> when 'true' ->
			  primop 'match_fail'
			      ({'case_clause',_1534})
		      -| ['compiler_generated'] )
		  end
	  %% Line 122
	  <[I|Is],Acc> when 'true' ->
	      %% Line 123
	      apply 'opt_1'/2
		  (Is, [I|_cor0])
	  %% Line 124
	  <[],Acc> when 'true' ->
	      call 'lists':'reverse'
		  (_cor0)
	  ( <_cor4,_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor1,_cor0})
		  -| [{'function_name',{'opt_1',2}}] )
	    -| ['compiler_generated'] )
	end
'move_past_kill'/3 =
    %% Line 126
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <[{'kill',Src}|_cor8],{'move',_cor9,_cor10},_cor11>
	      when call 'erlang':'=:='
		    (_cor9,
		     Src) ->
	      %% Line 127
	      'impossible'
	  %% Line 128
	  <[I = {'kill',_cor12}|Is],Move,Acc> when 'true' ->
	      %% Line 129
	      apply 'move_past_kill'/3
		  (Is, _cor1, [I|_cor0])
	  %% Line 130
	  <[I = {'trim',N,_cor13}|Is],Move = {'move',Src,Dst},Acc> when 'true' ->
	      %% Line 131
	      case Src of
		%% Line 132
		<{'y',Y}>
		    when call 'erlang':'<'
			  (Y,
			   N) ->
		    'impossible'
		%% Line 133
		<{'y',Y}> when 'true' ->
		    let <_cor3> =
			call 'erlang':'-'
			    (Y, N)
		    in  {Is,[{'move',{'y',_cor3},Dst}|[I|_cor0]]}
		%% Line 134
		<_cor14> when 'true' ->
		    {Is,[_cor1|[I|_cor0]]}
	      end
	  %% Line 136
	  <Is,Move,Acc> when 'true' ->
	      %% Line 137
	      {_cor2,[_cor1|_cor0]}
	end
'module_info'/0 =
    fun () ->
	call 'erlang':'get_module_info'
	    ('beam_flatten')
'module_info'/1 =
    fun (_cor0) ->
	call 'erlang':'get_module_info'
	    ('beam_flatten', _cor0)
end
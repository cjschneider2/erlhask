module 'beam_except' ['module'/2,
		      'module_info'/0,
		      'module_info'/1]
    attributes []
'module'/2 =
    %% Line 35
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <{Mod,Exp,Attr,Fs0,Lc},_X_Opt> when 'true' ->
	      let <_cor7> =
		  %% Line 36
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor4) ->
				case _cor4 of
				  <[F|_cor3]> when 'true' ->
				      let <_cor5> =
					  apply 'function'/1
					      (F)
				      in  let <_cor6> =
					      apply 'lc$^0'/1
						  (_cor3)
					  in  ( [_cor5|_cor6]
						-| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_670> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor4})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (Fs0)
		    -| ['list_comprehension'] )
	      in  %% Line 37
		  {'ok',{Mod,Exp,Attr,_cor7,Lc}}
	  ( <_cor10,_cor9> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor1,_cor0})
		  -| [{'function_name',{'module',2}}] )
	    -| ['compiler_generated'] )
	end
'function'/1 =
    %% Line 39
    fun (_cor0) ->
	case _cor0 of
	  <{'function',Name,Arity,CLabel,Is0}> when 'true' ->
	      %% Line 40
	      try
		  let <Is> =
		      %% Line 41
		      apply 'function_1'/1
			  (Is0)
		  in  %% Line 42
		      {'function',Name,Arity,CLabel,Is}
	      of <_cor2> ->
		  _cor2
	      catch <_cor5,_cor4,_cor3> ->
		  let <Stack> =
		      %% Line 45
		      call 'erlang':'get_stacktrace'
			  ()
		  in  do  %% Line 46
			  call 'io':'fwrite'
			      ([70|[117|[110|[99|[116|[105|[111|[110|[58|[32|[126|[119|[47|[126|[119|[10]]]]]]]]]]]]]]]], [Name|[Arity|[]]])
			  %% Line 47
			  call 'erlang':'raise'
			      (_cor5, _cor4, Stack)
	  ( <_cor7> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor0})
		  -| [{'function_name',{'function',1}}] )
	    -| ['compiler_generated'] )
	end
'function_1'/1 =
    %% Line 56
    fun (_cor0) ->
	%% Line 57
	case _cor0 of
	  %% Line 58
	  <[{'label',Lbl}|[{'line',Loc}|[{'func_info',_cor4,_cor5,Arity}|_cor6]]]> when 'true' ->
	      let <St> =
		  %% Line 59
		  {'st',Lbl,Loc,Arity}
	      in  %% Line 60
		  apply 'translate'/3
		      (_cor0, St, [])
	  %% Line 61
	  <[{'label',_cor7}|_cor8]> when 'true' ->
	      _cor0
	  ( <_cor2> when 'true' ->
		primop 'match_fail'
		    ({'case_clause',_cor0})
	    -| ['compiler_generated'] )
	end
'translate'/3 =
    %% Line 67
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <[I = {'call_ext',Ar,{'extfunc','erlang','error',_cor6}}|Is],St,Acc>
	      when call 'erlang':'=:='
		    (_cor6,
		     Ar) ->
	      %% Line 68
	      apply 'translate_1'/5
		  (Ar, I, Is, _cor1, _cor0)
	  %% Line 69
	  <[I|Is],St,Acc> when 'true' ->
	      %% Line 70
	      apply 'translate'/3
		  (Is, _cor1, [I|_cor0])
	  %% Line 71
	  <[],_cor7,Acc> when 'true' ->
	      %% Line 72
	      call 'lists':'reverse'
		  (_cor0)
	  ( <_cor5,_cor4,_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor2,_cor1,_cor0})
		  -| [{'function_name',{'translate',3}}] )
	    -| ['compiler_generated'] )
	end
'translate_1'/5 =
    %% Line 74
    fun (_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <Ar,I,Is,St,Acc0 = [Line = {'line',_cor13}|Acc1]> when 'true' ->
	      let <_2243> =
		  %% Line 75
		  apply 'dig_out'/2
		      (_cor4, Acc1)
	      in  %% Line 75
		  case _2243 of
		    %% Line 76
		    <'no'> when 'true' ->
			%% Line 77
			apply 'translate'/3
			    (_cor2, _cor1, [_cor3|_cor0])
		    %% Line 78
		    <{'yes',{'function_clause',Arity},Acc2}> when 'true' ->
			%% Line 79
			case <_cor13,_cor1> of
			  %% Line 80
			  <Loc,{'st',Fi,_cor14,_cor15}>
			      when let <_cor16> =
				    call 'erlang':'=:='
					(_cor14, _cor13)
				in  let <_cor17> =
					call 'erlang':'=:='
					    (_cor15, Arity)
				    in  call 'erlang':'and'
					    (_cor16, _cor17) ->
			      let <Instr> = {%% Line 81
				   'jump',%% Line 81
					  {'f',Fi}}
			      in  %% Line 82
				  apply 'translate'/3
				      (_cor2, _cor1, [Instr|Acc2])
			  %% Line 83
			  <_fol7,_cor19> when 'true' ->
			      %% Line 86
			      apply 'translate'/3
				  (_cor2, _cor1, [_cor3|_cor0])
			end
		    %% Line 88
		    <{'yes',Instr,Acc2}> when 'true' ->
			%% Line 89
			apply 'translate'/3
			    (_cor2, _cor1, [Instr|[Line|Acc2]])
		    ( <_cor7> when 'true' ->
			  primop 'match_fail'
			      ({'case_clause',_2243})
		      -| ['compiler_generated'] )
		  end
	  ( <_cor12,_cor11,_cor10,_cor9,_cor8> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor4,_cor3,_cor2,_cor1,_cor0})
		  -| [{'function_name',{'translate_1',5}}] )
	    -| ['compiler_generated'] )
	end
'dig_out'/2 =
    %% Line 92
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Ar,[{'kill',_cor7}|Is]> when 'true' ->
	      %% Line 93
	      apply 'dig_out'/2
		  (_cor1, Is)
	  %% Line 94
	  <1,[{'block',Bl0}|Is]> when 'true' ->
	      let <_cor2> =
		  %% Line 95
		  call 'lists':'reverse'
		      (Bl0)
	      in  let <_860> =
		      %% Line 95
		      apply 'dig_out_block'/1
			  (_cor2)
		  in  %% Line 95
		      case _860 of
			%% Line 96
			<'no'> when 'true' ->
			    'no'
			%% Line 97
			<{'yes',What,[]}> when 'true' ->
			    %% Line 98
			    {'yes',What,Is}
			%% Line 99
			<{'yes',What,Bl}> when 'true' ->
			    %% Line 100
			    {'yes',What,[{'block',Bl}|Is]}
			( <_cor3> when 'true' ->
			      primop 'match_fail'
				  ({'case_clause',_860})
			  -| ['compiler_generated'] )
		      end
	  %% Line 102
	  <2,[{'block',Bl}|Is]> when 'true' ->
	      let <_1217> =
		  %% Line 103
		  apply 'dig_out_block_fc'/1
		      (Bl)
	      in  %% Line 103
		  case _1217 of
		    %% Line 104
		    <'no'> when 'true' ->
			'no'
		    %% Line 105
		    <{'yes',What}> when 'true' ->
			{'yes',What,Is}
		    ( <_cor4> when 'true' ->
			  primop 'match_fail'
			      ({'case_clause',_1217})
		      -| ['compiler_generated'] )
		  end
	  %% Line 107
	  <_cor8,_cor9> when 'true' ->
	      'no'
	end
'dig_out_block'/1 =
    %% Line 109
    fun (_cor0) ->
	case _cor0 of
	  <[{'set',[{'x',0}],[{'atom','if_clause'}],'move'}]> when 'true' ->
	      %% Line 110
	      {'yes','if_end',[]}
	  %% Line 111
	  <[{'set',[{'x',0}],[{'literal',{Exc,Value}}|[]],'move'}|Is]> when 'true' ->
	      %% Line 112
	      apply 'translate_exception'/4
		  (Exc, {'literal',Value}, Is, 0)
	  %% Line 113
	  <[{'set',[{'x',0}],[Tuple|[]],'move'}|%% Line 114
						[{'set',[],[Value|[]],'put'}|%% Line 115
									     [{'set',[],[{'atom',Exc}|[]],'put'}|%% Line 116
														 [{'set',[_cor2|[]],[],{'put_tuple',2}}|Is]]]]>
	      when call 'erlang':'=:='
		    (_cor2,
		     Tuple) ->
	      %% Line 117
	      apply 'translate_exception'/4
		  (Exc, Value, Is, 3)
	  %% Line 118
	  <[{'set',[],[Value|[]],'put'}|%% Line 119
					[{'set',[],[{'atom',Exc}|[]],'put'}|%% Line 120
									    [{'set',[{'x',0}],[],{'put_tuple',2}}|Is]]]> when 'true' ->
	      %% Line 121
	      apply 'translate_exception'/4
		  (Exc, Value, Is, 3)
	  %% Line 122
	  <_cor3> when 'true' ->
	      'no'
	end
'translate_exception'/4 =
    %% Line 124
    fun (_cor3,_cor2,_cor1,_cor0) ->
	case <_cor3,_cor2,_cor1,_cor0> of
	  <'badmatch',Val,Is,Words> when 'true' ->
	      let <_cor4> =
		  %% Line 132
		  case <_cor1,_cor0> of
		    <_2161,0> when 'true' ->
			%% Line 133
			call 'lists':'reverse'
			    (_cor1)
		    %% Line 134
		    <_1509,_1883> when 'true' ->
			let <_1532> =
			    %% Line 135
			    call 'lists':'reverse'
				(_cor1)
			in  %% Line 135
			    apply 'fix_block_1'/2
				(_1532, _cor0)
		  end
	      in  %% Line 125
		  {'yes',{'badmatch',_cor2},_cor4}
	  %% Line 126
	  <'case_clause',Val,Is,Words> when 'true' ->
	      let <_cor5> =
		  %% Line 132
		  case <_cor1,_cor0> of
		    <_625,0> when 'true' ->
			%% Line 133
			call 'lists':'reverse'
			    (_cor1)
		    %% Line 134
		    <_51,_1043> when 'true' ->
			let <_793> =
			    %% Line 135
			    call 'lists':'reverse'
				(_cor1)
			in  %% Line 135
			    apply 'fix_block_1'/2
				(_793, _cor0)
		  end
	      in  %% Line 127
		  {'yes',{'case_end',_cor2},_cor5}
	  %% Line 128
	  <'try_clause',Val,Is,Words> when 'true' ->
	      let <_cor6> =
		  %% Line 132
		  case <_cor1,_cor0> of
		    <_2175,0> when 'true' ->
			%% Line 133
			call 'lists':'reverse'
			    (_cor1)
		    %% Line 134
		    <_122,_452> when 'true' ->
			let <_1355> =
			    %% Line 135
			    call 'lists':'reverse'
				(_cor1)
			in  %% Line 135
			    apply 'fix_block_1'/2
				(_1355, _cor0)
		  end
	      in  %% Line 129
		  {'yes',{'try_case_end',_cor2},_cor6}
	  %% Line 130
	  <_cor11,_cor12,_cor13,_cor14> when 'true' ->
	      'no'
	end
'fix_block_1'/2 =
    %% Line 137
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[{'set',[],[],{'alloc',Live,{F1,F2,Needed,F3}}}|Is],Words> when 'true' ->
	      let <_cor2> =
		  %% Line 138
		  call 'erlang':'-'
		      (Needed, _cor0)
	      in  %% Line 138
		  [{'set',[],[],{'alloc',Live,{F1,F2,_cor2,F3}}}|Is]
	  %% Line 139
	  <[I|Is],Words> when 'true' ->
	      let <_cor3> =
		  %% Line 140
		  apply 'fix_block_1'/2
		      (Is, _cor0)
	      in  %% Line 140
		  [I|_cor3]
	  ( <_cor5,_cor4> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor1,_cor0})
		  -| [{'function_name',{'fix_block_1',2}}] )
	    -| ['compiler_generated'] )
	end
'dig_out_block_fc'/1 =
    %% Line 142
    fun (_cor0) ->
	case _cor0 of
	  <[{'set',[],[],{'alloc',Live,_cor4}}|Bl]> when 'true' ->
	      let <_cor1> =
		  %% Line 143
		  call 'erlang':'-'
		      (Live, 1)
	      in  let <_1497> =
		      %% Line 143
		      apply 'dig_out_fc'/3
			  (Bl, _cor1, 'nil')
		  in  %% Line 143
		      case _1497 of
			%% Line 144
			<'no'> when 'true' ->
			    %% Line 145
			    'no'
			%% Line 146
			<'yes'> when 'true' ->
			    %% Line 147
			    {'yes',{'function_clause',Live}}
			( <_cor2> when 'true' ->
			      primop 'match_fail'
				  ({'case_clause',_1497})
			  -| ['compiler_generated'] )
		      end
	  %% Line 149
	  <_cor5> when 'true' ->
	      'no'
	end
'dig_out_fc'/3 =
    %% Line 151
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <[{'set',[Dst|[]],[{'x',Reg}|[Dst0|[]]],'put_list'}|Is],_cor7,_cor8>
	      when let <_cor9> =
		    call 'erlang':'=:='
			(_cor1, Reg)
		in  let <_cor10> =
			call 'erlang':'=:='
			    (_cor0, Dst0)
		    in  call 'erlang':'and'
			    (_cor9, _cor10) ->
	      let <_cor3> =
		  %% Line 152
		  call 'erlang':'-'
		      (Reg, 1)
	      in  %% Line 152
		  apply 'dig_out_fc'/3
		      (Is, _cor3, Dst)
	  %% Line 153
	  <[{'set',[{'x',0}],[{'atom','function_clause'}],'move'}],-1,{'x',1}> when 'true' ->
	      %% Line 154
	      'yes'
	  %% Line 155
	  <_cor11,_cor12,_cor13> when 'true' ->
	      'no'
	end
'module_info'/0 =
    fun () ->
	call 'erlang':'get_module_info'
	    ('beam_except')
'module_info'/1 =
    fun (_cor0) ->
	call 'erlang':'get_module_info'
	    ('beam_except', _cor0)
end
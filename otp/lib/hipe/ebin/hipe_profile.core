module 'hipe_profile' ['clear'/0,
		       'mods_res'/0,
		       'module_info'/0,
		       'module_info'/1,
		       'prof'/0,
		       'prof_module'/1,
		       'prof_module_off'/1,
		       'prof_off'/0,
		       'res'/0]
    attributes [%% Line 56
		'spec' =
		    %% Line 56
		    [{{'mods_res',0},[{'type',56,'fun',[{'type',56,'product',[]}|[{'type',56,'list',[{'type',56,'tuple',[{'type',56,'atom',[]}|[{'type',56,'non_neg_integer',[]}]]}]}]]}]}],
		%% Line 64
		'spec' =
		    %% Line 64
		    [{{'calls',0},[{'type',64,'fun',[{'type',64,'product',[]}|[{'type',64,'list',[{'type',64,'tuple',[{'type',64,'atom',[]}|[{'type',64,'non_neg_integer',[]}]]}]}]]}]}],
		%% Line 96
		'spec' =
		    %% Line 96
		    [{{'prof',0},[{'type',96,'fun',[{'type',96,'product',[]}|[{'atom',96,'ok'}]]}]}],
		%% Line 101
		'spec' =
		    %% Line 101
		    [{{'prof_off',0},[{'type',101,'fun',[{'type',101,'product',[]}|[{'atom',101,'ok'}]]}]}],
		%% Line 106
		'spec' =
		    %% Line 106
		    [{{'clear',0},[{'type',106,'fun',[{'type',106,'product',[]}|[{'atom',106,'ok'}]]}]}],
		%% Line 111
		'spec' =
		    %% Line 111
		    [{{'res',0},[{'type',111,'fun',[{'type',111,'product',[]}|[{'type',111,'list',[{'type',111,'tuple',[{'type',111,'mfa',[]}|[{'type',111,'non_neg_integer',[]}]]}]}]]}]}],
		%% Line 118
		'spec' =
		    %% Line 118
		    [{{'mods',0},[{'type',118,'fun',[{'type',118,'product',[]}|[{'type',118,'list',[{'type',118,'atom',[]}]}]]}]}],
		%% Line 126
		'spec' =
		    %% Line 126
		    [{{'prof_module',1},[{'type',126,'fun',[{'type',126,'product',[{'type',126,'atom',[]}]}|[{'atom',126,'ok'}]]}]}],
		%% Line 137
		'spec' =
		    %% Line 137
		    [{{'prof_module_off',1},[{'type',137,'fun',[{'type',137,'product',[{'type',137,'atom',[]}]}|[{'atom',137,'ok'}]]}]}],
		%% Line 148
		'spec' =
		    %% Line 148
		    [{{'clear_module',1},[{'type',148,'fun',[{'type',148,'product',[{'type',148,'atom',[]}]}|[{'atom',148,'ok'}]]}]}],
		%% Line 159
		'spec' =
		    %% Line 159
		    [{{'res_module',1},[{'type',159,'fun',[{'type',159,'product',[{'type',159,'atom',[]}]}|[{'type',159,'list',[{'type',159,'tuple',[{'type',159,'mfa',[]}|[{'type',159,'non_neg_integer',[]}]]}]}]]}]}],
		%% Line 177
		'spec' =
		    %% Line 177
		    [{{'total_calls',1},[{'type',177,'fun',[{'type',177,'product',[{'type',177,'atom',[]}]}|[{'type',177,'non_neg_integer',[]}]]}]}]]
'mods_res'/0 =
    %% Line 61
    fun () ->
	let <_cor0> =
	    %% Line 62
	    apply 'calls'/0
		()
	in  let <_cor1> =
		%% Line 62
		call 'lists':'keysort'
		    (2, _cor0)
	    in  %% Line 62
		call 'lists':'reverse'
		    (_cor1)
'calls'/0 =
    %% Line 67
    fun () ->
	%% Line 68
	( letrec
	      'lc$^0'/1 =
		  fun (_cor4) ->
		      case _cor4 of
			<[Mod|_cor1]> when 'true' ->
			    let <_cor3> =
				%% Line 69
				apply 'total_calls'/1
				    (Mod)
			    in  %% Line 69
				( case <> of
				    <>
					when call 'erlang':'>'
					      (_cor3,
					       1) ->
					%% Line 70
					( case <> of
					    <>
						when call 'erlang':'=/='
						      (Mod,
						       'hipe_profile') ->
						let <_cor5> =
						    apply 'total_calls'/1
							(Mod)
						in  let <_cor6> =
							apply 'lc$^0'/1
							    (_cor1)
						    in  ( [{Mod,_cor5}|_cor6]
							  -| ['compiler_generated'] )
					    ( <> when 'true' ->
						  apply 'lc$^0'/1
						      (_cor1)
					      -| ['compiler_generated'] )
					  end
					  -| ['list_comprehension'] )
				    ( <> when 'true' ->
					  apply 'lc$^0'/1
					      (_cor1)
				      -| ['compiler_generated'] )
				  end
				  -| ['list_comprehension'] )
			<[]> when 'true' ->
			    []
			( <_cor4> when 'true' ->
			      ( primop 'match_fail'
				    ({'function_clause',_cor4})
				-| [{'function_name',{'lc$^0',1}}] )
			  -| ['compiler_generated'] )
		      end
	  in  let <_cor2> =
		  apply 'mods'/0
		      ()
	      in  apply 'lc$^0'/1
		      (_cor2)
	  -| ['list_comprehension'] )
'prof'/0 =
    %% Line 98
    fun () ->
	let <_cor0> =
	    %% Line 99
	    apply 'mods'/0
		()
	in  %% Line 99
	    call 'lists':'foreach'
		(( 'prof_module'/1
		   -| [{'id',{0,0,'-prof/0-fun-0-'}}] ), _cor0)
'prof_off'/0 =
    %% Line 103
    fun () ->
	let <_cor0> =
	    %% Line 104
	    apply 'mods'/0
		()
	in  %% Line 104
	    call 'lists':'foreach'
		(( 'prof_module_off'/1
		   -| [{'id',{0,0,'-prof_off/0-fun-0-'}}] ), _cor0)
'clear'/0 =
    %% Line 108
    fun () ->
	let <_cor0> =
	    %% Line 109
	    apply 'mods'/0
		()
	in  %% Line 109
	    call 'lists':'foreach'
		(( 'clear_module'/1
		   -| [{'id',{0,0,'-clear/0-fun-0-'}}] ), _cor0)
'res'/0 =
    %% Line 114
    fun () ->
	let <_cor6> =
	    %% Line 115
	    ( letrec
		  'lc$^0'/1 =
		      fun (_cor3) ->
			  case _cor3 of
			    <[M|_cor1]> when 'true' ->
				let <_cor4> =
				    apply 'res_module'/1
					(M)
				in  let <_cor5> =
					apply 'lc$^0'/1
					    (_cor1)
				    in  ( [_cor4|_cor5]
					  -| ['compiler_generated'] )
			    <[]> when 'true' ->
				[]
			    ( <_cor3> when 'true' ->
				  ( primop 'match_fail'
					({'function_clause',_cor3})
				    -| [{'function_name',{'lc$^0',1}}] )
			      -| ['compiler_generated'] )
			  end
	      in  let <_cor2> =
		      apply 'mods'/0
			  ()
		  in  apply 'lc$^0'/1
			  (_cor2)
	      -| ['list_comprehension'] )
	in  let <_cor7> =
		%% Line 115
		call 'lists':'flatten'
		    (_cor6)
	    in  let <_cor8> =
		    %% Line 115
		    call 'lists':'keysort'
			(2, _cor7)
		in  %% Line 115
		    call 'lists':'reverse'
			(_cor8)
'mods'/0 =
    %% Line 122
    fun () ->
	%% Line 123
	( letrec
	      'lc$^0'/1 =
		  fun (_cor3) ->
		      case _cor3 of
			<[{Mod,_cor5}|_cor1]> when 'true' ->
			    let <_cor4> =
				apply 'lc$^0'/1
				    (_cor1)
			    in  ( [Mod|_cor4]
				  -| ['compiler_generated'] )
			( <[_cor0|_cor1]> when 'true' ->
			      apply 'lc$^0'/1
				  (_cor1)
			  -| ['compiler_generated'] )
			<[]> when 'true' ->
			    []
			( <_cor3> when 'true' ->
			      ( primop 'match_fail'
				    ({'function_clause',_cor3})
				-| [{'function_name',{'lc$^0',1}}] )
			  -| ['compiler_generated'] )
		      end
	  in  let <_cor2> =
		  call 'code':'all_loaded'
		      ()
	      in  apply 'lc$^0'/1
		      (_cor2)
	  -| ['list_comprehension'] )
'prof_module'/1 =
    %% Line 130
    fun (_cor0) ->
	let <Funs> =
	    %% Line 131
	    call _cor0:'module_info'
		('functions')
	in  let <_cor4> =
		%% Line 132
		( fun (_cor2) ->
		      case _cor2 of
			<{F,A}> when 'true' ->
			    catch
				call 'hipe_bifs':'call_count_on'
				    ({_cor0,F,A})
			( <_cor3> when 'true' ->
			      ( primop 'match_fail'
				    ({'function_clause',_cor3})
				-| [{'function_name',{'-prof_module/1-fun-0-',1}}] )
			  -| ['compiler_generated'] )
		      end
		  -| [{'id',{0,0,'-prof_module/1-fun-0-'}}] )
	    in  do  %% Line 132
		    call 'lists':'foreach'
			(_cor4, %% Line 133
				Funs)
		    %% Line 134
		    'ok'
'prof_module_off'/1 =
    %% Line 141
    fun (_cor0) ->
	let <Funs> =
	    %% Line 142
	    call _cor0:'module_info'
		('functions')
	in  let <_cor4> =
		%% Line 143
		( fun (_cor2) ->
		      case _cor2 of
			<{F,A}> when 'true' ->
			    catch
				call 'hipe_bifs':'call_count_off'
				    ({_cor0,F,A})
			( <_cor3> when 'true' ->
			      ( primop 'match_fail'
				    ({'function_clause',_cor3})
				-| [{'function_name',{'-prof_module_off/1-fun-0-',1}}] )
			  -| ['compiler_generated'] )
		      end
		  -| [{'id',{0,0,'-prof_module_off/1-fun-0-'}}] )
	    in  do  %% Line 143
		    call 'lists':'foreach'
			(_cor4, %% Line 144
				Funs)
		    %% Line 145
		    'ok'
'clear_module'/1 =
    %% Line 152
    fun (_cor0) ->
	let <Funs> =
	    %% Line 153
	    call _cor0:'module_info'
		('functions')
	in  let <_cor4> =
		%% Line 154
		( fun (_cor2) ->
		      case _cor2 of
			<{F,A}> when 'true' ->
			    catch
				call 'hipe_bifs':'call_count_clear'
				    ({_cor0,F,A})
			( <_cor3> when 'true' ->
			      ( primop 'match_fail'
				    ({'function_clause',_cor3})
				-| [{'function_name',{'-clear_module/1-fun-0-',1}}] )
			  -| ['compiler_generated'] )
		      end
		  -| [{'id',{0,0,'-clear_module/1-fun-0-'}}] )
	    in  do  %% Line 154
		    call 'lists':'foreach'
			(_cor4, %% Line 155
				Funs)
		    %% Line 156
		    'ok'
'res_module'/1 =
    %% Line 164
    fun (_cor0) ->
	let <Fun> =
	    %% Line 165
	    ( fun (_cor10) ->
		  case _cor10 of
		    <{F,A}>
			when let <_cor1> =
			      call 'erlang':'is_atom'
				  (F)
			  in  let <_cor2> =
				  call 'erlang':'is_integer'
				      (A)
			      in  call 'erlang':'and'
				      (_cor1, _cor2) ->
			let <MFA> = {_cor0,%% Line 166
				   F,%% Line 166
				     A}
			in  let <_cor9> =
				%% Line 167
				try
				    call 'hipe_bifs':'call_count_get'
					(MFA)
				of <_cor4> ->
				    case _cor4 of
				      %% Line 168
				      <N>
					  when call 'erlang':'is_integer'
						(_cor4) ->
					  N
				      %% Line 169
				      <'false'> when 'true' ->
					  0
				      ( <_cor5> when 'true' ->
					    primop 'match_fail'
						({'try_clause',_cor5})
					-| ['compiler_generated'] )
				    end
				catch <_cor8,_cor7,_cor6> ->
				    %% Line 171
				    0
			    in  %% Line 167
				{MFA,_cor9}
		    ( <_cor11> when 'true' ->
			  ( primop 'match_fail'
				({'function_clause',_cor11})
			    -| [{'function_name',{'-res_module/1-fun-0-',1}}] )
		      -| ['compiler_generated'] )
		  end
	      -| [{'id',{0,0,'-res_module/1-fun-0-'}}] )
	in  let <_cor19> =
		%% Line 175
		( letrec
		      'lc$^0'/1 =
			  fun (_cor16) ->
			      case _cor16 of
				<[FA|_cor14]> when 'true' ->
				    let <_cor17> =
					apply Fun
					    (FA)
				    in  let <_cor18> =
					    apply 'lc$^0'/1
						(_cor14)
					in  ( [_cor17|_cor18]
					      -| ['compiler_generated'] )
				<[]> when 'true' ->
				    []
				( <_cor16> when 'true' ->
				      ( primop 'match_fail'
					    ({'function_clause',_cor16})
					-| [{'function_name',{'lc$^0',1}}] )
				  -| ['compiler_generated'] )
			      end
		  in  let <_cor15> =
			  call _cor0:'module_info'
			      ('functions')
		      in  apply 'lc$^0'/1
			      (_cor15)
		  -| ['list_comprehension'] )
	    in  let <_cor20> =
		    %% Line 175
		    call 'lists':'keysort'
			(2, _cor19)
		in  %% Line 175
		    call 'lists':'reverse'
			(_cor20)
'total_calls'/1 =
    %% Line 179
    fun (_cor0) ->
	let <Funs> =
	    %% Line 180
	    call _cor0:'module_info'
		('functions')
	in  let <SumF> =
		%% Line 181
		( fun (_cor9,_cor8) ->
		      case <_cor9,_cor8> of
			<{F,A},Acc> when 'true' ->
			    let <MFA> = {_cor0,%% Line 182
				       F,%% Line 182
					 A}
			    in  %% Line 183
				try
				    call 'hipe_bifs':'call_count_get'
					(MFA)
				of <_cor3> ->
				    case _cor3 of
				      %% Line 184
				      <N>
					  when call 'erlang':'is_integer'
						(_cor3) ->
					  call 'erlang':'+'
					      (N, Acc)
				      %% Line 185
				      <'false'> when 'true' ->
					  Acc
				      ( <_cor4> when 'true' ->
					    primop 'match_fail'
						({'try_clause',_cor4})
					-| ['compiler_generated'] )
				    end
				catch <_cor7,_cor6,_cor5> ->
				    %% Line 187
				    Acc
			%% Line 189
			<_cor17,Acc> when 'true' ->
			    Acc
		      end
		  -| [{'id',{0,0,'-total_calls/1-fun-0-'}}] )
	    in  %% Line 191
		call 'lists':'foldl'
		    (SumF, 0, Funs)
'module_info'/0 =
    fun () ->
	call 'erlang':'get_module_info'
	    ('hipe_profile')
'module_info'/1 =
    fun (_cor0) ->
	call 'erlang':'get_module_info'
	    ('hipe_profile', _cor0)
end
module 'erl_bits' ['as_list'/1,
		   'module_info'/0,
		   'module_info'/1,
		   'set_bit_type'/2,
		   'system_bitdefault'/0,
		   'system_bittypes'/0]
    attributes [%% Line 22
		'type' =
		    %% Line 22
		    [{'bt_endian',{'type',22,'union',[{'atom',22,'big'}|[{'atom',22,'little'}|[{'atom',22,'native'}]]]},[]}],
		%% Line 23
		'type' =
		    %% Line 23
		    [{'bt_sign',{'type',23,'union',[{'atom',23,'signed'}|[{'atom',23,'unsigned'}]]},[]}],
		%% Line 24
		'type' =
		    %% Line 24
		    [{'bt_type',{'type',24,'union',[{'atom',24,'integer'}|[{'atom',24,'float'}|[{'atom',24,'binary'}|[{'atom',24,'utf8'}|[{'atom',24,'utf16'}|[{'atom',24,'utf32'}]]]]]]},[]}],
		%% Line 25
		'type' =
		    %% Line 25
		    [{'bt_unit',{'type',25,'range',[{'integer',25,1}|[{'integer',25,256}]]},[]}],
		%% Line 27
		'type' =
		    %% Line 27
		    [{{'record','bittype'},[{'typed_record_field',{'record_field',28,{'atom',28,'type'}},{'type',28,'union',[{'atom',28,'undefined'}|[{'type',28,'bt_type',[]}]]}}|[{'typed_record_field',{'record_field',29,{'atom',29,'unit'}},{'type',29,'union',[{'atom',29,'undefined'}|[{'type',29,'bt_unit',[]}]]}}|[{'typed_record_field',{'record_field',30,{'atom',30,'sign'}},{'type',30,'union',[{'atom',30,'undefined'}|[{'type',30,'bt_sign',[]}]]}}|[{'typed_record_field',{'record_field',31,{'atom',31,'endian'}},{'type',31,'union',[{'atom',31,'undefined'}|[{'type',31,'bt_endian',[]}]]}}]]]],[]}],
		%% Line 34
		'type' =
		    %% Line 34
		    [{{'record','bitdefault'},[{'record_field',35,{'atom',35,'integer'}}|[{'record_field',36,{'atom',36,'float'}}|[{'record_field',37,{'atom',37,'binary'}}]]],[]}],
		%% Line 31
		'spec' =
		    %% Line 31
		    [{{'system_bitdefault',0},[{'type',31,'fun',[{'type',31,'product',[]}|[{'atom',31,'no_system_bitdefault'}]]}]}],
		%% Line 35
		'spec' =
		    %% Line 35
		    [{{'system_bittypes',0},[{'type',35,'fun',[{'type',35,'product',[]}|[{'atom',35,'no_system_types'}]]}]}],
		%% Line 39
		'spec' =
		    %% Line 39
		    [{{'as_list',1},[{'type',39,'fun',[{'type',39,'product',[{'type',39,'record',[{'atom',39,'bittype'}]}]}|[{'type',40,'list',[{'type',40,'union',[{'type',40,'bt_endian',[]}|[{'type',40,'bt_sign',[]}|[{'type',40,'bt_type',[]}|[{'type',40,'tuple',[{'atom',40,'unit'}|[{'type',40,'union',[{'atom',40,'undefined'}|[{'type',40,'bt_unit',[]}]]}]]}]]]]}]}]]}]}],
		%% Line 47
		'type' =
		    %% Line 47
		    [{'size',{'type',47,'union',[{'atom',47,'all'}|[{'atom',47,'unknown'}|[{'type',47,'non_neg_integer',[]}|[{'type',47,'tuple','any'}]]]]},[]}],
		%% Line 48
		'type' =
		    %% Line 48
		    [{'type',{'type',48,'union',[{'atom',48,'bytes'}|[{'atom',48,'bitstring'}|[{'atom',48,'bits'}|[{'type',49,'bt_type',[]}|[{'type',49,'bt_endian',[]}|[{'type',49,'bt_sign',[]}|[{'type',50,'tuple',[{'atom',50,'unit'}|[{'type',50,'union',[{'atom',50,'undefined'}|[{'type',50,'bt_unit',[]}]]}]]}]]]]]]]},[]}],
		%% Line 52
		'spec' =
		    %% Line 52
		    [{{'set_bit_type',2},[{'type',52,'fun',[{'type',52,'product',[{'type',52,'union',[{'atom',52,'default'}|[{'type',52,'size',[]}]]}|[{'type',52,'union',[{'atom',52,'default'}|[{'type',52,'list',[{'type',52,'type',[]}]}]]}]]}|[{'type',53,'union',[{'type',53,'tuple',[{'atom',53,'ok'}|[{'type',53,'union',[{'atom',53,'undefined'}|[{'type',53,'size',[]}]]}|[{'type',53,'record',[{'atom',53,'bittype'}]}]]]}|[{'type',54,'tuple',[{'atom',54,'error'}|[{'type',54,'tuple',[{'atom',54,'undefined_bittype'}|[{'type',54,'term',[]}]]}]]}|[{'type',55,'tuple',[{'atom',55,'error'}|[{'type',55,'tuple',[{'atom',55,'bittype_mismatch'}|[{'type',55,'term',[]}|[{'type',55,'term',[]}|[{'type',55,'string',[]}]]]]}]]}]]]}]]}]}]]
'system_bitdefault'/0 =
    %% Line 33
    fun () ->
	'no_system_bitdefault'
'system_bittypes'/0 =
    %% Line 37
    fun () ->
	'no_system_types'
'as_list'/1 =
    %% Line 42
    fun (_cor0) ->
	%% Line 43
	( case _cor0 of
	    ( <( {'bittype',_rec0,_cor10,_cor11,_cor12}
		 -| ['compiler_generated'] )> when 'true' ->
		  [_rec0|[{'unit',_cor10}|[_cor11|[_cor12|[]]]]]
	      -| ['compiler_generated'] )
	    ( <_cor13> when 'true' ->
		  ( call ( 'erlang'
			   -| ['compiler_generated'] ):( 'error'
							 -| ['compiler_generated'] )
			(( {'badrecord','bittype'}
			   -| ['compiler_generated'] ))
		    -| ['compiler_generated'] )
	      -| ['compiler_generated'] )
	  end
	  -| ['compiler_generated'] )
'set_bit_type'/2 =
    %% Line 57
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Size,'default'> when 'true' ->
	      %% Line 58
	      apply 'set_bit_type'/2
		  (Size, [])
	  %% Line 59
	  <Size,TypeList> when 'true' ->
	      %% Line 60
	      try
		  %% Line 61
		  case %% Line 62
		       apply 'set_bit'/1
			   (TypeList) of
		    <{'bittype',Type,Unit,Sign,Endian}> when 'true' ->
			%% Line 63
			apply 'apply_defaults'/5
			    (Type, Size, Unit, Sign, Endian)
		    ( <_cor2> when 'true' ->
			  primop 'match_fail'
			      ({'badmatch',_cor2})
		      -| ['compiler_generated'] )
		  end
	      of <_cor3> ->
		  _cor3
	      catch <_cor6,_cor5,_cor4> ->
		  case <_cor6,_cor5,_cor4> of
		    %% Line 65
		    <'throw',Error,_cor9> when 'true' ->
			Error
		    ( <_cor6,_cor5,_cor4> when 'true' ->
			  primop 'raise'
			      (_cor4, _cor5)
		      -| ['compiler_generated'] )
		  end
	end
'set_bit'/1 =
    %% Line 68
    fun (_cor0) ->
	case _cor0 of
	  <[]> when 'true' ->
	      {'bittype','undefined','undefined','undefined','undefined'}
	  %% Line 69
	  <[H|T]> when 'true' ->
	      let <_cor1> =
		  apply 'type_to_record'/1
		      (H)
	      in  apply 'set_bit_1'/2
		      (T, _cor1)
	  ( <_cor2> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor2})
		  -| [{'function_name',{'set_bit',1}}] )
	    -| ['compiler_generated'] )
	end
'set_bit_1'/2 =
    %% Line 71
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[T0|Ts],Bt0> when 'true' ->
	      let <Type> =
		  %% Line 72
		  apply 'type_to_record'/1
		      (T0)
	      in  let <Bt> =
		      %% Line 73
		      apply 'merge_bittype'/2
			  (Type, Bt0)
		  in  %% Line 74
		      apply 'set_bit_1'/2
			  (Ts, Bt)
	  %% Line 75
	  <[],Bt> when 'true' ->
	      Bt
	  ( <_cor5,_cor4> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor5,_cor4})
		  -| [{'function_name',{'set_bit_1',2}}] )
	    -| ['compiler_generated'] )
	end
'type_to_record'/1 =
    %% Line 77
    fun (_cor0) ->
	case _cor0 of
	  <'integer'> when 'true' ->
	      {'bittype','integer','undefined','undefined','undefined'}
	  %% Line 78
	  <'utf8'> when 'true' ->
	      {'bittype','utf8','undefined','undefined','undefined'}
	  %% Line 79
	  <'utf16'> when 'true' ->
	      {'bittype','utf16','undefined','undefined','undefined'}
	  %% Line 80
	  <'utf32'> when 'true' ->
	      {'bittype','utf32','undefined','undefined','undefined'}
	  %% Line 81
	  <'float'> when 'true' ->
	      {'bittype','float','undefined','undefined','undefined'}
	  %% Line 82
	  <'binary'> when 'true' ->
	      {'bittype','binary','undefined','undefined','undefined'}
	  %% Line 83
	  <'bytes'> when 'true' ->
	      {'bittype','binary',8,'undefined','undefined'}
	  %% Line 84
	  <'bitstring'> when 'true' ->
	      {'bittype','binary',1,'undefined','undefined'}
	  %% Line 85
	  <'bits'> when 'true' ->
	      {'bittype','binary',1,'undefined','undefined'}
	  %% Line 87
	  <{'unit','undefined'}> when 'true' ->
	      %% Line 88
	      {'bittype','undefined','undefined','undefined','undefined'}
	  %% Line 89
	  <{'unit',Sz}>
	      when try
		    let <_cor1> =
			call 'erlang':'is_integer'
			    (Sz)
		    in  let <_cor2> =
			    call 'erlang':'>'
				(Sz, 0)
			in  let <_cor3> =
				call 'erlang':'=<'
				    (Sz, 256)
			    in  let <_cor4> =
				    call 'erlang':'and'
					(_cor2, _cor3)
				in  call 'erlang':'and'
					(_cor1, _cor4)
		of <Try> ->
		    Try
		catch <T,R> ->
		    'false' ->
	      %% Line 90
	      {'bittype','undefined',Sz,'undefined','undefined'}
	  %% Line 92
	  <'big'> when 'true' ->
	      {'bittype','undefined','undefined','undefined','big'}
	  %% Line 93
	  <'little'> when 'true' ->
	      {'bittype','undefined','undefined','undefined','little'}
	  %% Line 94
	  <'native'> when 'true' ->
	      {'bittype','undefined','undefined','undefined','native'}
	  %% Line 96
	  <'signed'> when 'true' ->
	      {'bittype','undefined','undefined','signed','undefined'}
	  %% Line 97
	  <'unsigned'> when 'true' ->
	      {'bittype','undefined','undefined','unsigned','undefined'}
	  %% Line 99
	  <Name> when 'true' ->
	      call 'erlang':'throw'
		  ({'error',{'undefined_bittype',Name}})
	end
'merge_bittype'/2 =
    %% Line 104
    fun (_cor1,_cor0) ->
	%% Line 105
	( case _cor1 of
	    ( <( {'bittype',_cor24,_cor25,_cor26,_rec4}
		 -| ['compiler_generated'] )> when 'true' ->
		  ( case _cor0 of
		      ( <( {'bittype',_cor28,_cor29,_cor30,_rec5}
			   -| ['compiler_generated'] )> when 'true' ->
			    let <Endian> =
				apply 'merge_field'/3
				    (_rec4, _rec5, 'endianness')
			    in  let <Sign> =
				    %% Line 106
				    apply 'merge_field'/3
					(_cor26, _cor30, 'sign')
				in  let <Type> =
					%% Line 107
					apply 'merge_field'/3
					    (_cor24, _cor28, 'type')
				    in  let <Unit> =
					    %% Line 108
					    apply 'merge_field'/3
						(_cor25, _cor29, 'unit')
					in  %% Line 109
					    {'bittype',Type,Unit,Sign,Endian}
			-| ['compiler_generated'] )
		      ( <_cor31> when 'true' ->
			    ( call ( 'erlang'
				     -| ['compiler_generated'] ):( 'error'
								   -| ['compiler_generated'] )
				  (( {'badrecord','bittype'}
				     -| ['compiler_generated'] ))
			      -| ['compiler_generated'] )
			-| ['compiler_generated'] )
		    end
		    -| ['compiler_generated'] )
	      -| ['compiler_generated'] )
	    ( <_cor27> when 'true' ->
		  ( call ( 'erlang'
			   -| ['compiler_generated'] ):( 'error'
							 -| ['compiler_generated'] )
			(( {'badrecord','bittype'}
			   -| ['compiler_generated'] ))
		    -| ['compiler_generated'] )
	      -| ['compiler_generated'] )
	  end
	  -| ['compiler_generated'] )
'merge_field'/3 =
    %% Line 111
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <'undefined',B,_cor7> when 'true' ->
	      B
	  %% Line 112
	  <A,'undefined',_cor8> when 'true' ->
	      A
	  %% Line 113
	  <A,_cor9,_cor10>
	      when call 'erlang':'=:='
		    (_cor9,
		     A) ->
	      A
	  %% Line 114
	  <X,Y,What> when 'true' ->
	      let <_cor3> =
		  %% Line 115
		  call 'erlang':'atom_to_list'
		      (What)
	      in  %% Line 115
		  call 'erlang':'throw'
		      ({'error',{'bittype_mismatch',X,Y,_cor3}})
	end
'apply_defaults'/5 =
    %% Line 128
    fun (_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <'undefined',Size,Unit,Sign,Endian> when 'true' ->
	      %% Line 129
	      apply 'apply_defaults'/5
		  ('integer', Size, Unit, Sign, Endian)
	  %% Line 131
	  <'binary','default',Unit,Sign,Endian> when 'true' ->
	      %% Line 133
	      apply 'apply_defaults'/5
		  ('binary', 'all', Unit, Sign, Endian)
	  %% Line 134
	  <'integer','default',Unit,Sign,Endian> when 'true' ->
	      do  %% Line 135
		  apply 'check_unit'/1
		      (Unit)
		  %% Line 136
		  apply 'apply_defaults'/5
		      ('integer', 8, 1, Sign, Endian)
	  %% Line 137
	  <Type = 'utf8','default',Unit,Sign,Endian> when 'true' ->
	      %% Line 138
	      apply 'apply_defaults'/5
		  (Type, 'undefined', Unit, Sign, Endian)
	  %% Line 139
	  <Type = 'utf16','default',Unit,Sign,Endian> when 'true' ->
	      %% Line 140
	      apply 'apply_defaults'/5
		  (Type, 'undefined', Unit, Sign, Endian)
	  %% Line 141
	  <Type = 'utf32','default',Unit,Sign,Endian> when 'true' ->
	      %% Line 142
	      apply 'apply_defaults'/5
		  (Type, 'undefined', Unit, Sign, Endian)
	  %% Line 143
	  <'float','default',Unit,Sign,Endian> when 'true' ->
	      do  %% Line 144
		  apply 'check_unit'/1
		      (Unit)
		  %% Line 145
		  apply 'apply_defaults'/5
		      ('float', 64, 1, Sign, Endian)
	  %% Line 147
	  <'binary',Size,'undefined',Sign,Endian> when 'true' ->
	      %% Line 148
	      apply 'apply_defaults'/5
		  ('binary', Size, 8, Sign, Endian)
	  %% Line 149
	  <'integer',Size,'undefined',Sign,Endian> when 'true' ->
	      %% Line 150
	      apply 'apply_defaults'/5
		  ('integer', Size, 1, Sign, Endian)
	  %% Line 151
	  <'float',Size,'undefined',Sign,Endian> when 'true' ->
	      %% Line 152
	      apply 'apply_defaults'/5
		  ('float', Size, 1, Sign, Endian)
	  %% Line 154
	  <Type,Size,Unit,'undefined',Endian> when 'true' ->
	      %% Line 155
	      apply 'apply_defaults'/5
		  (Type, Size, Unit, 'unsigned', Endian)
	  %% Line 157
	  <Type,Size,Unit,Sign,'undefined'> when 'true' ->
	      %% Line 158
	      apply 'apply_defaults'/5
		  (Type, Size, Unit, Sign, 'big')
	  %% Line 160
	  <Type,Size,Unit,Sign,Endian> when 'true' ->
	      do  %% Line 161
		  apply 'check_size_unit'/3
		      (Type, Size, Unit)
		  %% Line 162
		  {'ok',Size,{'bittype',Type,Unit,Sign,Endian}}
	end
'check_size_unit'/3 =
    %% Line 164
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <'utf8',Size,Unit> when 'true' ->
	      %% Line 165
	      apply 'check_size_unit_1'/2
		  (Size, Unit)
	  %% Line 166
	  <'utf16',Size,Unit> when 'true' ->
	      %% Line 167
	      apply 'check_size_unit_1'/2
		  (Size, Unit)
	  %% Line 168
	  <'utf32',Size,Unit> when 'true' ->
	      %% Line 169
	      apply 'check_size_unit_1'/2
		  (Size, Unit)
	  %% Line 170
	  <_cor6,_cor7,_cor8> when 'true' ->
	      'ok'
	end
'check_size_unit_1'/2 =
    %% Line 172
    fun (_cor1,_cor0) ->
	do  %% Line 173
	    case _cor1 of
	      %% Line 174
	      <'default'> when 'true' ->
		  'ok'
	      %% Line 175
	      <'undefined'> when 'true' ->
		  'ok'
	      %% Line 176
	      <{'atom',_cor6,'undefined'}> when 'true' ->
		  'ok'
	      %% Line 177
	      <{'value',_cor7,'undefined'}> when 'true' ->
		  'ok'
	      %% Line 178
	      <_cor8> when 'true' ->
		  call 'erlang':'throw'
		      ({'error','utf_bittype_size_or_unit'})
	    end
	    %% Line 180
	    case _cor0 of
	      %% Line 181
	      <'undefined'> when 'true' ->
		  'ok'
	      %% Line 182
	      <_cor9> when 'true' ->
		  call 'erlang':'throw'
		      ({'error','utf_bittype_size_or_unit'})
	    end
'check_unit'/1 =
    %% Line 185
    fun (_cor0) ->
	case _cor0 of
	  <'undefined'> when 'true' ->
	      'ok'
	  %% Line 186
	  <_cor2> when 'true' ->
	      call 'erlang':'throw'
		  ({'error','bittype_unit'})
	end
'module_info'/0 =
    fun () ->
	call 'erlang':'get_module_info'
	    ('erl_bits')
'module_info'/1 =
    fun (_cor0) ->
	call 'erlang':'get_module_info'
	    ('erl_bits', _cor0)
end
module 're' ['compile'/1,
	     'compile'/2,
	     'grun'/3,
	     'inspect'/2,
	     'module_info'/0,
	     'module_info'/1,
	     'replace'/3,
	     'replace'/4,
	     'run'/2,
	     'run'/3,
	     'split'/2,
	     'split'/3,
	     'ucompile'/2,
	     'urun'/3]
    attributes [%% Line 22
		'type' =
		    %% Line 22
		    [{'mp',{'type',22,'tuple',[{'atom',22,'re_pattern'}|[{'var',22,'_'}|[{'var',22,'_'}|[{'var',22,'_'}|[{'var',22,'_'}]]]]]},[]}],
		%% Line 24
		'type' =
		    %% Line 24
		    [{'nl_spec',{'type',24,'union',[{'atom',24,'cr'}|[{'atom',24,'crlf'}|[{'atom',24,'lf'}|[{'atom',24,'anycrlf'}|[{'atom',24,'any'}]]]]]},[]}],
		%% Line 26
		'type' =
		    %% Line 26
		    [{'compile_option',{'type',26,'union',[{'atom',26,'unicode'}|[{'atom',26,'anchored'}|[{'atom',26,'caseless'}|[{'atom',26,'dollar_endonly'}|[{'atom',27,'dotall'}|[{'atom',27,'extended'}|[{'atom',27,'firstline'}|[{'atom',27,'multiline'}|[{'atom',28,'no_auto_capture'}|[{'atom',28,'dupnames'}|[{'atom',28,'ungreedy'}|[{'type',29,'tuple',[{'atom',29,'newline'}|[{'type',29,'nl_spec',[]}]]}|[{'atom',30,'bsr_anycrlf'}|[{'atom',30,'bsr_unicode'}|[{'atom',31,'no_start_optimize'}|[{'atom',31,'ucp'}|[{'atom',31,'never_utf'}]]]]]]]]]]]]]]]]]},[]}],
		%% Line 37
		'spec' =
		    %% Line 37
		    [{{'compile',1},[{'type',37,'bounded_fun',[{'type',37,'fun',[{'type',37,'product',[{'var',37,'Regexp'}]}|[{'type',37,'union',[{'type',37,'tuple',[{'atom',37,'ok'}|[{'var',37,'MP'}]]}|[{'type',37,'tuple',[{'atom',37,'error'}|[{'var',37,'ErrSpec'}]]}]]}]]}|[[{'type',38,'constraint',[{'atom',38,'is_subtype'}|[[{'var',38,'Regexp'}|[{'type',38,'iodata',[]}]]]]}|[{'type',39,'constraint',[{'atom',39,'is_subtype'}|[[{'var',39,'MP'}|[{'type',39,'mp',[]}]]]]}|[{'type',40,'constraint',[{'atom',40,'is_subtype'}|[[{'var',40,'ErrSpec'}|[{'type',40,'tuple',[{'ann_type',40,[{'var',40,'ErrString'}|[{'type',40,'string',[]}]]}|[{'ann_type',40,[{'var',40,'Position'}|[{'type',40,'non_neg_integer',[]}]]}]]}]]]]}]]]]]}]}],
		%% Line 45
		'spec' =
		    %% Line 45
		    [{{'compile',2},[{'type',45,'bounded_fun',[{'type',45,'fun',[{'type',45,'product',[{'var',45,'Regexp'}|[{'var',45,'Options'}]]}|[{'type',45,'union',[{'type',45,'tuple',[{'atom',45,'ok'}|[{'var',45,'MP'}]]}|[{'type',45,'tuple',[{'atom',45,'error'}|[{'var',45,'ErrSpec'}]]}]]}]]}|[[{'type',46,'constraint',[{'atom',46,'is_subtype'}|[[{'var',46,'Regexp'}|[{'type',46,'union',[{'type',46,'iodata',[]}|[{'remote_type',46,[{'atom',46,'unicode'}|[{'atom',46,'charlist'}|[[]]]]}]]}]]]]}|[{'type',47,'constraint',[{'atom',47,'is_subtype'}|[[{'var',47,'Options'}|[{'type',47,'list',[{'var',47,'Option'}]}]]]]}|[{'type',48,'constraint',[{'atom',48,'is_subtype'}|[[{'var',48,'Option'}|[{'type',48,'compile_option',[]}]]]]}|[{'type',49,'constraint',[{'atom',49,'is_subtype'}|[[{'var',49,'MP'}|[{'type',49,'mp',[]}]]]]}|[{'type',50,'constraint',[{'atom',50,'is_subtype'}|[[{'var',50,'ErrSpec'}|[{'type',50,'tuple',[{'ann_type',50,[{'var',50,'ErrString'}|[{'type',50,'string',[]}]]}|[{'ann_type',50,[{'var',50,'Position'}|[{'type',50,'non_neg_integer',[]}]]}]]}]]]]}]]]]]]]}]}],
		%% Line 55
		'spec' =
		    %% Line 55
		    [{{'run',2},[{'type',55,'bounded_fun',[{'type',55,'fun',[{'type',55,'product',[{'var',55,'Subject'}|[{'var',55,'RE'}]]}|[{'type',55,'union',[{'type',55,'tuple',[{'atom',55,'match'}|[{'var',55,'Captured'}]]}|[{'atom',55,'nomatch'}]]}]]}|[[{'type',56,'constraint',[{'atom',56,'is_subtype'}|[[{'var',56,'Subject'}|[{'type',56,'union',[{'type',56,'iodata',[]}|[{'remote_type',56,[{'atom',56,'unicode'}|[{'atom',56,'charlist'}|[[]]]]}]]}]]]]}|[{'type',57,'constraint',[{'atom',57,'is_subtype'}|[[{'var',57,'RE'}|[{'type',57,'union',[{'type',57,'mp',[]}|[{'type',57,'iodata',[]}]]}]]]]}|[{'type',58,'constraint',[{'atom',58,'is_subtype'}|[[{'var',58,'Captured'}|[{'type',58,'list',[{'var',58,'CaptureData'}]}]]]]}|[{'type',59,'constraint',[{'atom',59,'is_subtype'}|[[{'var',59,'CaptureData'}|[{'type',59,'tuple',[{'type',59,'integer',[]}|[{'type',59,'integer',[]}]]}]]]]}]]]]]]}]}],
		%% Line 64
		'spec' =
		    %% Line 64
		    [{{'run',3},[{'type',64,'bounded_fun',[{'type',64,'fun',[{'type',64,'product',[{'var',64,'Subject'}|[{'var',64,'RE'}|[{'var',64,'Options'}]]]}|[{'type',64,'union',[{'type',64,'tuple',[{'atom',64,'match'}|[{'var',64,'Captured'}]]}|[{'atom',65,'match'}|[{'atom',66,'nomatch'}|[{'type',67,'tuple',[{'atom',67,'error'}|[{'var',67,'ErrType'}]]}]]]]}]]}|[[{'type',68,'constraint',[{'atom',68,'is_subtype'}|[[{'var',68,'Subject'}|[{'type',68,'union',[{'type',68,'iodata',[]}|[{'remote_type',68,[{'atom',68,'unicode'}|[{'atom',68,'charlist'}|[[]]]]}]]}]]]]}|[{'type',69,'constraint',[{'atom',69,'is_subtype'}|[[{'var',69,'RE'}|[{'type',69,'union',[{'type',69,'mp',[]}|[{'type',69,'iodata',[]}|[{'remote_type',69,[{'atom',69,'unicode'}|[{'atom',69,'charlist'}|[[]]]]}]]]}]]]]}|[{'type',70,'constraint',[{'atom',70,'is_subtype'}|[[{'var',70,'Options'}|[{'type',70,'list',[{'var',70,'Option'}]}]]]]}|[{'type',71,'constraint',[{'atom',71,'is_subtype'}|[[{'var',71,'Option'}|[{'type',71,'union',[{'atom',71,'anchored'}|[{'atom',71,'global'}|[{'atom',71,'notbol'}|[{'atom',71,'noteol'}|[{'atom',71,'notempty'}|[{'atom',72,'notempty_atstart'}|[{'atom',72,'report_errors'}|[{'type',73,'tuple',[{'atom',73,'offset'}|[{'type',73,'non_neg_integer',[]}]]}|[{'type',74,'tuple',[{'atom',74,'match_limit'}|[{'type',74,'non_neg_integer',[]}]]}|[{'type',75,'tuple',[{'atom',75,'match_limit_recursion'}|[{'type',75,'non_neg_integer',[]}]]}|[{'type',76,'tuple',[{'atom',76,'newline'}|[{'ann_type',76,[{'var',76,'NLSpec'}|[{'type',76,'nl_spec',[]}]]}]]}|[{'atom',77,'bsr_anycrlf'}|[{'atom',77,'bsr_unicode'}|[{'type',77,'tuple',[{'atom',77,'capture'}|[{'var',77,'ValueSpec'}]]}|[{'type',78,'tuple',[{'atom',78,'capture'}|[{'var',78,'ValueSpec'}|[{'var',78,'Type'}]]]}|[{'var',78,'CompileOpt'}]]]]]]]]]]]]]]]]}]]]]}|[{'type',79,'constraint',[{'atom',79,'is_subtype'}|[[{'var',79,'Type'}|[{'type',79,'union',[{'atom',79,'index'}|[{'atom',79,'list'}|[{'atom',79,'binary'}]]]}]]]]}|[{'type',80,'constraint',[{'atom',80,'is_subtype'}|[[{'var',80,'ValueSpec'}|[{'type',80,'union',[{'atom',80,'all'}|[{'atom',80,'all_but_first'}|[{'atom',80,'all_names'}|[{'atom',80,'first'}|[{'atom',80,'none'}|[{'var',80,'ValueList'}]]]]]]}]]]]}|[{'type',81,'constraint',[{'atom',81,'is_subtype'}|[[{'var',81,'ValueList'}|[{'type',81,'list',[{'var',81,'ValueID'}]}]]]]}|[{'type',82,'constraint',[{'atom',82,'is_subtype'}|[[{'var',82,'ValueID'}|[{'type',82,'union',[{'type',82,'integer',[]}|[{'type',82,'string',[]}|[{'type',82,'atom',[]}]]]}]]]]}|[{'type',83,'constraint',[{'atom',83,'is_subtype'}|[[{'var',83,'CompileOpt'}|[{'type',83,'compile_option',[]}]]]]}|[{'type',84,'constraint',[{'atom',84,'is_subtype'}|[[{'var',84,'Captured'}|[{'type',84,'union',[{'type',84,'list',[{'var',84,'CaptureData'}]}|[{'type',84,'list',[{'type',84,'list',[{'var',84,'CaptureData'}]}]}]]}]]]]}|[{'type',85,'constraint',[{'atom',85,'is_subtype'}|[[{'var',85,'CaptureData'}|[{'type',85,'union',[{'type',85,'tuple',[{'type',85,'integer',[]}|[{'type',85,'integer',[]}]]}|[{'var',86,'ListConversionData'}|[{'type',87,'binary',[]}]]]}]]]]}|[{'type',88,'constraint',[{'atom',88,'is_subtype'}|[[{'var',88,'ListConversionData'}|[{'type',88,'union',[{'type',88,'string',[]}|[{'type',89,'tuple',[{'atom',89,'error'}|[{'type',89,'string',[]}|[{'type',89,'binary',[]}]]]}|[{'type',90,'tuple',[{'atom',90,'incomplete'}|[{'type',90,'string',[]}|[{'type',90,'binary',[]}]]]}]]]}]]]]}|[{'type',91,'constraint',[{'atom',91,'is_subtype'}|[[{'var',91,'ErrType'}|[{'type',91,'union',[{'atom',91,'match_limit'}|[{'atom',91,'match_limit_recursion'}|[{'type',91,'tuple',[{'atom',91,'compile'}|[{'var',91,'CompileErr'}]]}]]]}]]]]}|[{'type',92,'constraint',[{'atom',92,'is_subtype'}|[[{'var',92,'CompileErr'}|[{'type',92,'tuple',[{'ann_type',92,[{'var',92,'ErrString'}|[{'type',92,'string',[]}]]}|[{'ann_type',92,[{'var',92,'Position'}|[{'type',92,'non_neg_integer',[]}]]}]]}]]]]}]]]]]]]]]]]]]]]]}]}],
		%% Line 97
		'spec' =
		    %% Line 97
		    [{{'inspect',2},[{'type',97,'bounded_fun',[{'type',97,'fun',[{'type',97,'product',[{'var',97,'MP'}|[{'var',97,'Item'}]]}|[{'type',97,'tuple',[{'atom',97,'namelist'}|[{'type',97,'list',[{'type',97,'binary',[]}]}]]}]]}|[[{'type',98,'constraint',[{'atom',98,'is_subtype'}|[[{'var',98,'MP'}|[{'type',98,'mp',[]}]]]]}|[{'type',99,'constraint',[{'atom',99,'is_subtype'}|[[{'var',99,'Item'}|[{'atom',99,'namelist'}]]]]}]]]]}]}],
		%% Line 107
		'spec' =
		    %% Line 107
		    [{{'split',2},[{'type',107,'bounded_fun',[{'type',107,'fun',[{'type',107,'product',[{'var',107,'Subject'}|[{'var',107,'RE'}]]}|[{'var',107,'SplitList'}]]}|[[{'type',108,'constraint',[{'atom',108,'is_subtype'}|[[{'var',108,'Subject'}|[{'type',108,'union',[{'type',108,'iodata',[]}|[{'remote_type',108,[{'atom',108,'unicode'}|[{'atom',108,'charlist'}|[[]]]]}]]}]]]]}|[{'type',109,'constraint',[{'atom',109,'is_subtype'}|[[{'var',109,'RE'}|[{'type',109,'union',[{'type',109,'mp',[]}|[{'type',109,'iodata',[]}]]}]]]]}|[{'type',110,'constraint',[{'atom',110,'is_subtype'}|[[{'var',110,'SplitList'}|[{'type',110,'list',[{'type',110,'union',[{'type',110,'iodata',[]}|[{'remote_type',110,[{'atom',110,'unicode'}|[{'atom',110,'charlist'}|[[]]]]}]]}]}]]]]}]]]]]}]}],
		%% Line 115
		'spec' =
		    %% Line 115
		    [{{'split',3},[{'type',115,'bounded_fun',[{'type',115,'fun',[{'type',115,'product',[{'var',115,'Subject'}|[{'var',115,'RE'}|[{'var',115,'Options'}]]]}|[{'var',115,'SplitList'}]]}|[[{'type',116,'constraint',[{'atom',116,'is_subtype'}|[[{'var',116,'Subject'}|[{'type',116,'union',[{'type',116,'iodata',[]}|[{'remote_type',116,[{'atom',116,'unicode'}|[{'atom',116,'charlist'}|[[]]]]}]]}]]]]}|[{'type',117,'constraint',[{'atom',117,'is_subtype'}|[[{'var',117,'RE'}|[{'type',117,'union',[{'type',117,'mp',[]}|[{'type',117,'iodata',[]}|[{'remote_type',117,[{'atom',117,'unicode'}|[{'atom',117,'charlist'}|[[]]]]}]]]}]]]]}|[{'type',118,'constraint',[{'atom',118,'is_subtype'}|[[{'var',118,'Options'}|[{'type',118,'list',[{'var',118,'Option'}]}]]]]}|[{'type',119,'constraint',[{'atom',119,'is_subtype'}|[[{'var',119,'Option'}|[{'type',119,'union',[{'atom',119,'anchored'}|[{'atom',119,'notbol'}|[{'atom',119,'noteol'}|[{'atom',119,'notempty'}|[{'atom',119,'notempty_atstart'}|[{'type',120,'tuple',[{'atom',120,'offset'}|[{'type',120,'non_neg_integer',[]}]]}|[{'type',120,'tuple',[{'atom',120,'newline'}|[{'type',120,'nl_spec',[]}]]}|[{'type',121,'tuple',[{'atom',121,'match_limit'}|[{'type',121,'non_neg_integer',[]}]]}|[{'type',122,'tuple',[{'atom',122,'match_limit_recursion'}|[{'type',122,'non_neg_integer',[]}]]}|[{'atom',123,'bsr_anycrlf'}|[{'atom',123,'bsr_unicode'}|[{'type',123,'tuple',[{'atom',123,'return'}|[{'var',123,'ReturnType'}]]}|[{'type',124,'tuple',[{'atom',124,'parts'}|[{'var',124,'NumParts'}]]}|[{'atom',124,'group'}|[{'atom',124,'trim'}|[{'var',124,'CompileOpt'}]]]]]]]]]]]]]]]]}]]]]}|[{'type',125,'constraint',[{'atom',125,'is_subtype'}|[[{'var',125,'NumParts'}|[{'type',125,'union',[{'type',125,'non_neg_integer',[]}|[{'atom',125,'infinity'}]]}]]]]}|[{'type',126,'constraint',[{'atom',126,'is_subtype'}|[[{'var',126,'ReturnType'}|[{'type',126,'union',[{'atom',126,'iodata'}|[{'atom',126,'list'}|[{'atom',126,'binary'}]]]}]]]]}|[{'type',127,'constraint',[{'atom',127,'is_subtype'}|[[{'var',127,'CompileOpt'}|[{'type',127,'compile_option',[]}]]]]}|[{'type',128,'constraint',[{'atom',128,'is_subtype'}|[[{'var',128,'SplitList'}|[{'type',128,'union',[{'type',128,'list',[{'var',128,'RetData'}]}|[{'type',128,'list',[{'var',128,'GroupedRetData'}]}]]}]]]]}|[{'type',129,'constraint',[{'atom',129,'is_subtype'}|[[{'var',129,'GroupedRetData'}|[{'type',129,'list',[{'var',129,'RetData'}]}]]]]}|[{'type',130,'constraint',[{'atom',130,'is_subtype'}|[[{'var',130,'RetData'}|[{'type',130,'union',[{'type',130,'iodata',[]}|[{'remote_type',130,[{'atom',130,'unicode'}|[{'atom',130,'charlist'}|[[]]]]}|[{'type',130,'binary',[]}|[{'type',130,'list',[]}]]]]}]]]]}]]]]]]]]]]]]}]}],
		%% Line 301
		'spec' =
		    %% Line 301
		    [{{'replace',3},[{'type',301,'bounded_fun',[{'type',301,'fun',[{'type',301,'product',[{'var',301,'Subject'}|[{'var',301,'RE'}|[{'var',301,'Replacement'}]]]}|[{'type',301,'union',[{'type',301,'iodata',[]}|[{'remote_type',301,[{'atom',301,'unicode'}|[{'atom',301,'charlist'}|[[]]]]}]]}]]}|[[{'type',302,'constraint',[{'atom',302,'is_subtype'}|[[{'var',302,'Subject'}|[{'type',302,'union',[{'type',302,'iodata',[]}|[{'remote_type',302,[{'atom',302,'unicode'}|[{'atom',302,'charlist'}|[[]]]]}]]}]]]]}|[{'type',303,'constraint',[{'atom',303,'is_subtype'}|[[{'var',303,'RE'}|[{'type',303,'union',[{'type',303,'mp',[]}|[{'type',303,'iodata',[]}]]}]]]]}|[{'type',304,'constraint',[{'atom',304,'is_subtype'}|[[{'var',304,'Replacement'}|[{'type',304,'union',[{'type',304,'iodata',[]}|[{'remote_type',304,[{'atom',304,'unicode'}|[{'atom',304,'charlist'}|[[]]]]}]]}]]]]}]]]]]}]}],
		%% Line 309
		'spec' =
		    %% Line 309
		    [{{'replace',4},[{'type',309,'bounded_fun',[{'type',309,'fun',[{'type',309,'product',[{'var',309,'Subject'}|[{'var',309,'RE'}|[{'var',309,'Replacement'}|[{'var',309,'Options'}]]]]}|[{'type',309,'union',[{'type',309,'iodata',[]}|[{'remote_type',309,[{'atom',309,'unicode'}|[{'atom',309,'charlist'}|[[]]]]}]]}]]}|[[{'type',310,'constraint',[{'atom',310,'is_subtype'}|[[{'var',310,'Subject'}|[{'type',310,'union',[{'type',310,'iodata',[]}|[{'remote_type',310,[{'atom',310,'unicode'}|[{'atom',310,'charlist'}|[[]]]]}]]}]]]]}|[{'type',311,'constraint',[{'atom',311,'is_subtype'}|[[{'var',311,'RE'}|[{'type',311,'union',[{'type',311,'mp',[]}|[{'type',311,'iodata',[]}|[{'remote_type',311,[{'atom',311,'unicode'}|[{'atom',311,'charlist'}|[[]]]]}]]]}]]]]}|[{'type',312,'constraint',[{'atom',312,'is_subtype'}|[[{'var',312,'Replacement'}|[{'type',312,'union',[{'type',312,'iodata',[]}|[{'remote_type',312,[{'atom',312,'unicode'}|[{'atom',312,'charlist'}|[[]]]]}]]}]]]]}|[{'type',313,'constraint',[{'atom',313,'is_subtype'}|[[{'var',313,'Options'}|[{'type',313,'list',[{'var',313,'Option'}]}]]]]}|[{'type',314,'constraint',[{'atom',314,'is_subtype'}|[[{'var',314,'Option'}|[{'type',314,'union',[{'atom',314,'anchored'}|[{'atom',314,'global'}|[{'atom',314,'notbol'}|[{'atom',314,'noteol'}|[{'atom',314,'notempty'}|[{'atom',315,'notempty_atstart'}|[{'type',316,'tuple',[{'atom',316,'offset'}|[{'type',316,'non_neg_integer',[]}]]}|[{'type',316,'tuple',[{'atom',316,'newline'}|[{'var',316,'NLSpec'}]]}|[{'atom',316,'bsr_anycrlf'}|[{'type',317,'tuple',[{'atom',317,'match_limit'}|[{'type',317,'non_neg_integer',[]}]]}|[{'type',318,'tuple',[{'atom',318,'match_limit_recursion'}|[{'type',318,'non_neg_integer',[]}]]}|[{'atom',319,'bsr_unicode'}|[{'type',319,'tuple',[{'atom',319,'return'}|[{'var',319,'ReturnType'}]]}|[{'var',319,'CompileOpt'}]]]]]]]]]]]]]]}]]]]}|[{'type',320,'constraint',[{'atom',320,'is_subtype'}|[[{'var',320,'ReturnType'}|[{'type',320,'union',[{'atom',320,'iodata'}|[{'atom',320,'list'}|[{'atom',320,'binary'}]]]}]]]]}|[{'type',321,'constraint',[{'atom',321,'is_subtype'}|[[{'var',321,'CompileOpt'}|[{'type',321,'compile_option',[]}]]]]}|[{'type',322,'constraint',[{'atom',322,'is_subtype'}|[[{'var',322,'NLSpec'}|[{'type',322,'union',[{'atom',322,'cr'}|[{'atom',322,'crlf'}|[{'atom',322,'lf'}|[{'atom',322,'anycrlf'}|[{'atom',322,'any'}]]]]]}]]]]}]]]]]]]]]]}]}]]
'compile'/1 =
    %% Line 42
    fun (_cor0) ->
	%% Line 43
	call 'erlang':'nif_error'
	    ('undef')
'compile'/2 =
    %% Line 52
    fun (_cor1,_cor0) ->
	%% Line 53
	call 'erlang':'nif_error'
	    ('undef')
'run'/2 =
    %% Line 61
    fun (_cor1,_cor0) ->
	%% Line 62
	call 'erlang':'nif_error'
	    ('undef')
'run'/3 =
    %% Line 94
    fun (_cor2,_cor1,_cor0) ->
	%% Line 95
	call 'erlang':'nif_error'
	    ('undef')
'inspect'/2 =
    %% Line 101
    fun (_cor1,_cor0) ->
	%% Line 102
	call 'erlang':'nif_error'
	    ('undef')
'split'/2 =
    %% Line 112
    fun (_cor1,_cor0) ->
	%% Line 113
	apply 'split'/3
	    (_cor1, _cor0, [])
'split'/3 =
    %% Line 132
    fun (_cor2,_cor1,_cor0) ->
	%% Line 133
	try
	    %% Line 134
	    case %% Line 135
		 apply 'process_split_params'/6
		     (_cor0, 'iodata', 'false', -1, 'false', 'false') of
	      <{NewOpt,Convert,Unicode,Limit,Strip,Group}> when 'true' ->
		  let <FlatSubject> =
		      %% Line 136
		      apply 'to_binary'/2
			  (_cor2, Unicode)
		  in  %% Line 137
		      case apply 'compile_split'/2
			       (_cor1, NewOpt) of
			%% Line 138
			<{'error',_X_Err}> when 'true' ->
			    %% Line 139
			    call 'erlang':'throw'
				('badre')
			%% Line 140
			<{PreCompiled,NumSub,RunOpt}> when 'true' ->
			    let <_cor6> =
				%% Line 142
				call 'erlang':'++'
				    (RunOpt, ['global'])
			    in  %% Line 142
				case call 're':'run'
					 (FlatSubject, PreCompiled, _cor6) of
				  %% Line 143
				  <'nomatch'> when 'true' ->
				      %% Line 144
				      case Group of
					%% Line 145
					<'true'> when 'true' ->
					    %% Line 146
					    apply 'convert_any_split_result'/4
						([[FlatSubject|[]]|[]], %% Line 147
									Convert, %% Line 147
										 Unicode, %% Line 147
											  'true')
					%% Line 148
					<'false'> when 'true' ->
					    %% Line 149
					    apply 'convert_any_split_result'/4
						([FlatSubject|[]], %% Line 150
								   Convert, %% Line 150
									    Unicode, %% Line 150
										     'false')
					( <_cor7> when 'true' ->
					      primop 'match_fail'
						  ({'case_clause',_cor7})
					  -| ['compiler_generated'] )
				      end
				  %% Line 152
				  <{'match',Matches}> when 'true' ->
				      let <Res> =
					  %% Line 153
					  apply 'do_split'/6
					      (FlatSubject, 0, Matches, NumSub, %% Line 154
										Limit, %% Line 154
										       Group)
				      in  let <_cor10> =
					      %% Line 155
					      case Strip of
						%% Line 156
						<'true'> when 'true' ->
						    %% Line 157
						    apply 'backstrip_empty'/2
							(Res, Group)
						%% Line 158
						<'false'> when 'true' ->
						    %% Line 159
						    Res
						( <_cor9> when 'true' ->
						      primop 'match_fail'
							  ({'case_clause',_cor9})
						  -| ['compiler_generated'] )
					      end
					  in  %% Line 161
					      apply 'convert_any_split_result'/4
						  (_cor10, Convert, Unicode, Group)
				  ( <_cor12> when 'true' ->
					primop 'match_fail'
					    ({'case_clause',_cor12})
				    -| ['compiler_generated'] )
				end
			( <_cor13> when 'true' ->
			      primop 'match_fail'
				  ({'case_clause',_cor13})
			  -| ['compiler_generated'] )
		      end
	      ( <_cor4> when 'true' ->
		    primop 'match_fail'
			({'badmatch',_cor4})
		-| ['compiler_generated'] )
	    end
	of <_cor14> ->
	    _cor14
	catch <_cor17,_cor16,_cor15> ->
	    case <_cor17,_cor16,_cor15> of
	      %% Line 165
	      <'throw','badopt',_cor21> when 'true' ->
		  %% Line 166
		  call 'erlang':'error'
		      ('badarg', [_cor2|[_cor1|[_cor0|[]]]])
	      %% Line 167
	      <'throw','badre',_cor22> when 'true' ->
		  %% Line 168
		  call 'erlang':'error'
		      ('badarg', [_cor2|[_cor1|[_cor0|[]]]])
	      %% Line 169
	      <'error','badarg',_cor23> when 'true' ->
		  %% Line 170
		  call 'erlang':'error'
		      ('badarg', [_cor2|[_cor1|[_cor0|[]]]])
	      ( <_cor17,_cor16,_cor15> when 'true' ->
		    primop 'raise'
			(_cor15, _cor16)
		-| ['compiler_generated'] )
	    end
'backstrip_empty'/2 =
    %% Line 173
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <List,'false'> when 'true' ->
	      %% Line 174
	      apply 'do_backstrip_empty'/1
		  (List)
	  %% Line 175
	  <List,'true'> when 'true' ->
	      %% Line 176
	      apply 'do_backstrip_empty_g'/1
		  (List)
	  ( <_cor3,_cor2> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor3,_cor2})
		  -| [{'function_name',{'backstrip_empty',2}}] )
	    -| ['compiler_generated'] )
	end
'do_backstrip_empty_g'/1 =
    %% Line 178
    fun (_cor0) ->
	case _cor0 of
	  <[]> when 'true' ->
	      %% Line 179
	      []
	  %% Line 180
	  <[H|[]]> when 'true' ->
	      %% Line 181
	      case apply 'do_backstrip_empty'/1
		       (H) of
		%% Line 182
		<[]> when 'true' ->
		    %% Line 183
		    []
		%% Line 184
		<_cor5> when 'true' ->
		    %% Line 185
		    [H|[]]
	      end
	  %% Line 187
	  <[H|T]> when 'true' ->
	      %% Line 188
	      case apply 'do_backstrip_empty_g'/1
		       (T) of
		%% Line 189
		<[]> when 'true' ->
		    %% Line 190
		    case apply 'do_backstrip_empty'/1
			     (H) of
		      %% Line 191
		      <[]> when 'true' ->
			  %% Line 192
			  []
		      %% Line 193
		      <_cor6> when 'true' ->
			  %% Line 194
			  [H|[]]
		    end
		%% Line 196
		<Other> when 'true' ->
		    %% Line 197
		    [H|Other]
	      end
	  ( <_cor4> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor4})
		  -| [{'function_name',{'do_backstrip_empty_g',1}}] )
	    -| ['compiler_generated'] )
	end
'do_backstrip_empty'/1 =
    %% Line 200
    fun (_cor0) ->
	case _cor0 of
	  <[]> when 'true' ->
	      %% Line 201
	      []
	  %% Line 202
	  <[#{}#|[]]> when 'true' ->
	      %% Line 203
	      []
	  %% Line 204
	  <[#{}#|T]> when 'true' ->
	      %% Line 205
	      case apply 'do_backstrip_empty'/1
		       (T) of
		%% Line 206
		<[]> when 'true' ->
		    %% Line 207
		    []
		%% Line 208
		<Other> when 'true' ->
		    %% Line 209
		    [#{}#|Other]
	      end
	  %% Line 211
	  <[H|T]> when 'true' ->
	      let <_cor2> =
		  %% Line 212
		  apply 'do_backstrip_empty'/1
		      (T)
	      in  %% Line 212
		  [H|_cor2]
	  ( <_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor3})
		  -| [{'function_name',{'do_backstrip_empty',1}}] )
	    -| ['compiler_generated'] )
	end
'convert_any_split_result'/4 =
    %% Line 214
    fun (_cor3,_cor2,_cor1,_cor0) ->
	case <_cor3,_cor2,_cor1,_cor0> of
	  <List,Type,Uni,'true'> when 'true' ->
	      %% Line 215
	      ( letrec
		    'lc$^0'/1 =
			fun (_cor6) ->
			    case _cor6 of
			      <[Part|_cor5]> when 'true' ->
				  let <_cor7> =
				      apply 'convert_split_result'/3
					  (Part, Type, Uni)
				  in  let <_cor8> =
					  apply 'lc$^0'/1
					      (_cor5)
				      in  ( [_cor7|_cor8]
					    -| ['compiler_generated'] )
			      <[]> when 'true' ->
				  []
			      ( <_cor6> when 'true' ->
				    ( primop 'match_fail'
					  ({'function_clause',_cor6})
				      -| [{'function_name',{'lc$^0',1}}] )
				-| ['compiler_generated'] )
			    end
		in  apply 'lc$^0'/1
			(List)
		-| ['list_comprehension'] )
	  %% Line 216
	  <List,Type,Uni,'false'> when 'true' ->
	      %% Line 217
	      apply 'convert_split_result'/3
		  (List, Type, Uni)
	  ( <_cor12,_cor11,_cor10,_cor9> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor12,_cor11,_cor10,_cor9})
		  -| [{'function_name',{'convert_any_split_result',4}}] )
	    -| ['compiler_generated'] )
	end
'convert_split_result'/3 =
    %% Line 219
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <List,'iodata',_X_Unicode> when 'true' ->
	      %% Line 220
	      List
	  %% Line 221
	  <List,'binary',_X_Unicode> when 'true' ->
	      %% Line 223
	      List
	  %% Line 224
	  <List,'list','true'> when 'true' ->
	      %% Line 225
	      ( letrec
		    'lc$^0'/1 =
			fun (_cor5) ->
			    case _cor5 of
			      <[Element|_cor4]> when 'true' ->
				  let <_cor6> =
				      call 'unicode':'characters_to_list'
					  (Element, 'unicode')
				  in  let <_cor7> =
					  apply 'lc$^0'/1
					      (_cor4)
				      in  ( [_cor6|_cor7]
					    -| ['compiler_generated'] )
			      <[]> when 'true' ->
				  []
			      ( <_cor5> when 'true' ->
				    ( primop 'match_fail'
					  ({'function_clause',_cor5})
				      -| [{'function_name',{'lc$^0',1}}] )
				-| ['compiler_generated'] )
			    end
		in  apply 'lc$^0'/1
			(List)
		-| ['list_comprehension'] )
	  %% Line 226
	  <List,'list','false'> when 'true' ->
	      %% Line 227
	      ( letrec
		    'lc$^1'/1 =
			fun (_cor10) ->
			    case _cor10 of
			      <[Element|_cor9]> when 'true' ->
				  let <_cor11> =
				      call 'erlang':'binary_to_list'
					  (Element)
				  in  let <_cor12> =
					  apply 'lc$^1'/1
					      (_cor9)
				      in  ( [_cor11|_cor12]
					    -| ['compiler_generated'] )
			      <[]> when 'true' ->
				  []
			      ( <_cor10> when 'true' ->
				    ( primop 'match_fail'
					  ({'function_clause',_cor10})
				      -| [{'function_name',{'lc$^1',1}}] )
				-| ['compiler_generated'] )
			    end
		in  apply 'lc$^1'/1
			(List)
		-| ['list_comprehension'] )
	  ( <_cor15,_cor14,_cor13> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor15,_cor14,_cor13})
		  -| [{'function_name',{'convert_split_result',3}}] )
	    -| ['compiler_generated'] )
	end
'do_split'/6 =
    %% Line 229
    fun (_cor5,_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor5,_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <Subj,Off,_cor31,_cor32,0,'false'> when 'true' ->
	      %% Line 230
	      case ( Subj
		     -| ['reuse_for_context'] ) of
		<#{#<_cor33>(Off,8,'binary',['unsigned'|['big']]),
		   #<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
		    %% Line 231
		    [Rest|[]]
		( <_cor6> when 'true' ->
		      do  primop 'bs_context_to_binary'
			      (_cor6)
			  primop 'match_fail'
			      ({'badmatch',_cor6})
		  -| ['compiler_generated'] )
	      end
	  %% Line 232
	  <Subj,Off,[],_cor34,_cor35,'false'> when 'true' ->
	      %% Line 233
	      case ( Subj
		     -| ['reuse_for_context'] ) of
		<#{#<_cor36>(Off,8,'binary',['unsigned'|['big']]),
		   #<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
		    %% Line 234
		    [Rest|[]]
		( <_cor7> when 'true' ->
		      do  primop 'bs_context_to_binary'
			      (_cor7)
			  primop 'match_fail'
			      ({'badmatch',_cor7})
		  -| ['compiler_generated'] )
	      end
	  %% Line 235
	  <Subj,Off,_cor37,_cor38,_cor39,'false'>
	      when try
		    let <_cor8> =
			call 'erlang':'byte_size'
			    (Subj)
		    in  call 'erlang':'=<'
			    (_cor8, Off)
		of <Try> ->
		    Try
		catch <T,R> ->
		    'false' ->
	      %% Line 236
	      [#{}#]
	  %% Line 237
	  <Subj,Off,_cor40,_cor41,0,'true'> when 'true' ->
	      %% Line 238
	      case ( Subj
		     -| ['reuse_for_context'] ) of
		<#{#<_cor42>(Off,8,'binary',['unsigned'|['big']]),
		   #<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
		    %% Line 239
		    [[Rest|[]]|[]]
		( <_cor9> when 'true' ->
		      do  primop 'bs_context_to_binary'
			      (_cor9)
			  primop 'match_fail'
			      ({'badmatch',_cor9})
		  -| ['compiler_generated'] )
	      end
	  %% Line 240
	  <Subj,Off,[],_cor43,_cor44,'true'> when 'true' ->
	      %% Line 241
	      case ( Subj
		     -| ['reuse_for_context'] ) of
		<#{#<_cor45>(Off,8,'binary',['unsigned'|['big']]),
		   #<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
		    %% Line 242
		    [[Rest|[]]|[]]
		( <_cor10> when 'true' ->
		      do  primop 'bs_context_to_binary'
			      (_cor10)
			  primop 'match_fail'
			      ({'badmatch',_cor10})
		  -| ['compiler_generated'] )
	      end
	  %% Line 243
	  <Subj,Off,_cor46,_cor47,_cor48,'true'>
	      when try
		    let <_cor11> =
			call 'erlang':'byte_size'
			    (Subj)
		    in  call 'erlang':'=<'
			    (_cor11, Off)
		of <Try> ->
		    Try
		catch <T,R> ->
		    'false' ->
	      %% Line 244
	      [[#{}#]]
	  %% Line 245
	  <Subj,Offset,[[{MainI,MainL}|Sub]|T],NumSub,Limit,Group> when 'true' ->
	      let <NewOffset> =
		  %% Line 246
		  call 'erlang':'+'
		      (MainI, MainL)
	      in  let <KeptLen> =
		      %% Line 247
		      call 'erlang':'-'
			  (MainI, Offset)
		  in  let <_cor14> =
			  %% Line 248
			  apply 'empty_sub'/1
			      (Sub)
		      in  %% Line 248
			  case <KeptLen,_cor14,MainL> of
			    %% Line 249
			    <0,'true',0> when 'true' ->
				%% Line 250
				apply 'do_split'/6
				    (Subj, NewOffset, T, NumSub, Limit, Group)
			    %% Line 251
			    <_fol15,_fol16,_fol17> when 'true' ->
				%% Line 252
				case Subj of
				  <#{#<_cor50>(Offset,8,'binary',['unsigned'|['big']]),
				     #<Keep>(KeptLen,8,'binary',['unsigned'|['big']]),
				     #<_cor51>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
				      let <ESub> =
					  %% Line 253
					  apply 'extend_subpatterns'/2
					      (Sub, NumSub)
				      in  let <_cor17> =
					      %% Line 254
					      call 'erlang':'-'
						  (Limit, 1)
					  in  let <Tail> =
						  %% Line 254
						  apply 'do_split'/6
						      (Subj, NewOffset, T, NumSub, _cor17, Group)
					      in  %% Line 255
						  case Group of
						    %% Line 256
						    <'false'> when 'true' ->
							let <_cor19> =
							    %% Line 257
							    call 'lists':'reverse'
								(ESub)
							in  let <_cor20> =
								%% Line 257
								apply 'dig_subpatterns'/3
								    (Subj, _cor19, Tail)
							    in  %% Line 257
								[Keep|_cor20]
						    %% Line 258
						    <'true'> when 'true' ->
							let <_cor21> =
							    %% Line 259
							    call 'lists':'reverse'
								(ESub)
							in  let <_cor22> =
								%% Line 259
								apply 'dig_subpatterns'/3
								    (Subj, _cor21, [])
							    in  %% Line 259
								[[Keep|_cor22]|%% Line 260
									       Tail]
						    ( <_cor23> when 'true' ->
							  primop 'match_fail'
							      ({'case_clause',_cor23})
						      -| ['compiler_generated'] )
						  end
				  ( <_cor15> when 'true' ->
					primop 'match_fail'
					    ({'badmatch',_cor15})
				    -| ['compiler_generated'] )
				end
			  end
	  ( <_cor30,_cor29,_cor28,_cor27,_cor26,_cor25> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor30,_cor29,_cor28,_cor27,_cor26,_cor25})
		  -| [{'function_name',{'do_split',6}}] )
	    -| ['compiler_generated'] )
	end
'empty_sub'/1 =
    %% Line 263
    fun (_cor0) ->
	case _cor0 of
	  <[]> when 'true' ->
	      %% Line 264
	      'true'
	  %% Line 265
	  <[{_cor2,0}|T]> when 'true' ->
	      %% Line 266
	      apply 'empty_sub'/1
		  (T)
	  %% Line 267
	  <_cor3> when 'true' ->
	      %% Line 268
	      'false'
	end
'dig_subpatterns'/3 =
    %% Line 270
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <_cor7,[],Acc> when 'true' ->
	      %% Line 271
	      Acc
	  %% Line 272
	  <Subj,[{-1,0}|T],Acc> when 'true' ->
	      %% Line 273
	      apply 'dig_subpatterns'/3
		  (Subj, T, [#{}#|Acc])
	  %% Line 274
	  <Subj,[{I,L}|T],Acc> when 'true' ->
	      %% Line 275
	      case Subj of
		<#{#<_cor8>(I,8,'binary',['unsigned'|['big']]),
		   #<Part>(L,8,'binary',['unsigned'|['big']]),
		   #<_cor9>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
		    %% Line 276
		    apply 'dig_subpatterns'/3
			(Subj, T, [Part|Acc])
		( <_cor3> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor3})
		  -| ['compiler_generated'] )
	      end
	  ( <_cor6,_cor5,_cor4> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor6,_cor5,_cor4})
		  -| [{'function_name',{'dig_subpatterns',3}}] )
	    -| ['compiler_generated'] )
	end
'extend_subpatterns'/2 =
    %% Line 278
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <_cor8,0> when 'true' ->
	      %% Line 279
	      []
	  %% Line 280
	  <[],N> when 'true' ->
	      let <_cor2> =
		  %% Line 281
		  call 'erlang':'-'
		      (N, 1)
	      in  let <_cor3> =
		      %% Line 281
		      apply 'extend_subpatterns'/2
			  ([], _cor2)
		  in  %% Line 281
		      [{0,0}|_cor3]
	  %% Line 282
	  <[H|T],N> when 'true' ->
	      let <_cor4> =
		  %% Line 283
		  call 'erlang':'-'
		      (N, 1)
	      in  let <_cor5> =
		      %% Line 283
		      apply 'extend_subpatterns'/2
			  (T, _cor4)
		  in  %% Line 283
		      [H|_cor5]
	  ( <_cor7,_cor6> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor7,_cor6})
		  -| [{'function_name',{'extend_subpatterns',2}}] )
	    -| ['compiler_generated'] )
	end
'compile_split'/2 =
    %% Line 285
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Comp = {'re_pattern',N,_cor16,_cor17,_cor18},Options> when 'true' ->
	      %% Line 286
	      {Comp,N,Options}
	  %% Line 287
	  <Pat,Options0>
	      when let <_cor2> =
		    call 'erlang':'is_tuple'
			(Pat)
		in  call 'erlang':'not'
			(_cor2) ->
	      let <_cor6> =
		  %% Line 288
		  ( fun (_cor4) ->
			let <_cor3> =
			    %% Line 289
			    apply 'runopt'/1
				(_cor4)
			in  %% Line 289
			    call 'erlang':'not'
				(_cor3)
		    -| [{'id',{0,0,'-compile_split/2-fun-0-'}}] )
	      in  let <Options> =
		      %% Line 288
		      call 'lists':'filter'
			  (_cor6, %% Line 290
				  Options0)
		  in  %% Line 291
		      case call 're':'compile'
			       (Pat, Options) of
			%% Line 292
			<{'error',Err}> when 'true' ->
			    %% Line 293
			    {'error',Err}
			%% Line 294
			<{'ok',Comp = {'re_pattern',N,_cor19,_cor20,_cor21}}> when 'true' ->
			    let <_cor11> =
				%% Line 295
				( fun (_cor9) ->
				      let <_cor8> =
					  apply 'copt'/1
					      (_cor9)
				      in  call 'erlang':'not'
					      (_cor8)
				  -| [{'id',{0,0,'-compile_split/2-fun-1-'}}] )
			    in  let <NewOpt> =
				    %% Line 295
				    call 'lists':'filter'
					(_cor11, Options0)
				in  %% Line 296
				    {Comp,N,NewOpt}
			( <_cor13> when 'true' ->
			      primop 'match_fail'
				  ({'case_clause',_cor13})
			  -| ['compiler_generated'] )
		      end
	  %% Line 298
	  <_cor22,_cor23> when 'true' ->
	      %% Line 299
	      call 'erlang':'throw'
		  ('badre')
	end
'replace'/3 =
    %% Line 306
    fun (_cor2,_cor1,_cor0) ->
	%% Line 307
	apply 'replace'/4
	    (_cor2, _cor1, _cor0, [])
'replace'/4 =
    %% Line 324
    fun (_cor3,_cor2,_cor1,_cor0) ->
	%% Line 325
	try
	    %% Line 326
	    case %% Line 327
		 apply 'process_repl_params'/3
		     (_cor0, 'iodata', 'false') of
	      <{NewOpt,Convert,Unicode}> when 'true' ->
		  let <FlatSubject> =
		      %% Line 328
		      apply 'to_binary'/2
			  (_cor3, Unicode)
		  in  let <FlatReplacement> =
			  %% Line 329
			  apply 'to_binary'/2
			      (_cor1, Unicode)
		      in  let <IoList> =
			      %% Line 330
			      apply 'do_replace'/5
				  (FlatSubject, _cor3, _cor2, FlatReplacement, NewOpt)
			  in  %% Line 331
			      case Convert of
				%% Line 332
				<'iodata'> when 'true' ->
				    %% Line 333
				    IoList
				%% Line 334
				<'binary'> when 'true' ->
				    %% Line 335
				    case Unicode of
				      %% Line 336
				      <'false'> when 'true' ->
					  %% Line 337
					  call 'erlang':'iolist_to_binary'
					      (IoList)
				      %% Line 338
				      <'true'> when 'true' ->
					  %% Line 339
					  call 'unicode':'characters_to_binary'
					      (IoList, 'unicode')
				      ( <_cor8> when 'true' ->
					    primop 'match_fail'
						({'case_clause',_cor8})
					-| ['compiler_generated'] )
				    end
				%% Line 341
				<'list'> when 'true' ->
				    %% Line 342
				    case Unicode of
				      %% Line 343
				      <'false'> when 'true' ->
					  let <_cor9> =
					      %% Line 344
					      call 'erlang':'iolist_to_binary'
						  (IoList)
					  in  %% Line 344
					      call 'erlang':'binary_to_list'
						  (_cor9)
				      %% Line 345
				      <'true'> when 'true' ->
					  %% Line 346
					  call 'unicode':'characters_to_list'
					      (IoList, 'unicode')
				      ( <_cor10> when 'true' ->
					    primop 'match_fail'
						({'case_clause',_cor10})
					-| ['compiler_generated'] )
				    end
				( <_cor11> when 'true' ->
				      primop 'match_fail'
					  ({'case_clause',_cor11})
				  -| ['compiler_generated'] )
			      end
	      ( <_cor4> when 'true' ->
		    primop 'match_fail'
			({'badmatch',_cor4})
		-| ['compiler_generated'] )
	    end
	of <_cor12> ->
	    _cor12
	catch <_cor15,_cor14,_cor13> ->
	    case <_cor15,_cor14,_cor13> of
	      %% Line 350
	      <'throw','badopt',_cor20> when 'true' ->
		  %% Line 351
		  call 'erlang':'error'
		      ('badarg', [_cor3|[_cor2|[_cor1|[_cor0|[]]]]])
	      %% Line 352
	      <'throw','badre',_cor21> when 'true' ->
		  %% Line 353
		  call 'erlang':'error'
		      ('badarg', [_cor3|[_cor2|[_cor1|[_cor0|[]]]]])
	      %% Line 354
	      <'error','badarg',_cor22> when 'true' ->
		  %% Line 355
		  call 'erlang':'error'
		      ('badarg', [_cor3|[_cor2|[_cor1|[_cor0|[]]]]])
	      ( <_cor15,_cor14,_cor13> when 'true' ->
		    primop 'raise'
			(_cor13, _cor14)
		-| ['compiler_generated'] )
	    end
'do_replace'/5 =
    %% Line 359
    fun (_cor4,_cor3,_cor2,_cor1,_cor0) ->
	%% Line 360
	case call 're':'run'
		 (_cor4, _cor2, _cor0) of
	  %% Line 361
	  <'nomatch'> when 'true' ->
	      _cor3
	  %% Line 363
	  <{'match',[Mlist|T]}>
	      when call 'erlang':'is_list'
		    (Mlist) ->
	      %% Line 364
	      apply 'apply_mlist'/3
		  (_cor4, _cor1, [Mlist|T])
	  %% Line 365
	  <{'match',Slist}> when 'true' ->
	      %% Line 366
	      apply 'apply_mlist'/3
		  (_cor4, _cor1, [Slist|[]])
	  ( <_cor5> when 'true' ->
		primop 'match_fail'
		    ({'case_clause',_cor5})
	    -| ['compiler_generated'] )
	end
'process_repl_params'/3 =
    %% Line 369
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <[],Convert,Unicode> when 'true' ->
	      %% Line 370
	      {[],Convert,Unicode}
	  %% Line 371
	  <['unicode'|T],C,_X_U> when 'true' ->
	      %% Line 372
	      case apply 'process_repl_params'/3
		       (T, C, 'true') of
		<{NT,NC,NU}> when 'true' ->
		    %% Line 373
		    {['unicode'|NT],NC,NU}
		( <_cor3> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor3})
		  -| ['compiler_generated'] )
	      end
	  %% Line 374
	  <['report_errors'|_cor8],_cor9,_cor10> when 'true' ->
	      %% Line 375
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 376
	  <[{'capture',_cor11,_cor12}|_cor13],_cor14,_cor15> when 'true' ->
	      %% Line 377
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 378
	  <[{'capture',_cor16}|_cor17],_cor18,_cor19> when 'true' ->
	      %% Line 379
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 380
	  <[{'return','iodata'}|T],_X_C,U> when 'true' ->
	      %% Line 381
	      apply 'process_repl_params'/3
		  (T, 'iodata', U)
	  %% Line 382
	  <[{'return','list'}|T],_X_C,U> when 'true' ->
	      %% Line 383
	      apply 'process_repl_params'/3
		  (T, 'list', U)
	  %% Line 384
	  <[{'return','binary'}|T],_X_C,U> when 'true' ->
	      %% Line 385
	      apply 'process_repl_params'/3
		  (T, 'binary', U)
	  %% Line 386
	  <[{'return',_cor20}|_cor21],_cor22,_cor23> when 'true' ->
	      %% Line 387
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 388
	  <[H|T],C,U> when 'true' ->
	      %% Line 389
	      case apply 'process_repl_params'/3
		       (T, C, U) of
		<{NT,NC,NU}> when 'true' ->
		    %% Line 390
		    {[H|NT],NC,NU}
		( <_cor4> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor4})
		  -| ['compiler_generated'] )
	      end
	  ( <_cor7,_cor6,_cor5> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor7,_cor6,_cor5})
		  -| [{'function_name',{'process_repl_params',3}}] )
	    -| ['compiler_generated'] )
	end
'process_split_params'/6 =
    %% Line 392
    fun (_cor5,_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor5,_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <[],Convert,Unicode,Limit,Strip,Group> when 'true' ->
	      %% Line 393
	      {[],Convert,Unicode,Limit,Strip,Group}
	  %% Line 394
	  <['unicode'|T],C,_X_U,L,S,G> when 'true' ->
	      %% Line 395
	      case apply 'process_split_params'/6
		       (T, C, 'true', L, S, G) of
		<{NT,NC,NU,NL,NS,NG}> when 'true' ->
		    %% Line 396
		    {['unicode'|NT],NC,NU,NL,NS,NG}
		( <_cor6> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor6})
		  -| ['compiler_generated'] )
	      end
	  %% Line 397
	  <['trim'|T],C,U,_X_L,_X_S,G> when 'true' ->
	      %% Line 398
	      apply 'process_split_params'/6
		  (T, C, U, -1, 'true', G)
	  %% Line 399
	  <[{'parts',0}|T],C,U,_X_L,_X_S,G> when 'true' ->
	      %% Line 400
	      apply 'process_split_params'/6
		  (T, C, U, -1, 'true', G)
	  %% Line 401
	  <[{'parts',N}|T],C,U,_X_L,_X_S,G>
	      when let <_cor9> =
		    call 'erlang':'is_integer'
			(N)
		in  let <_cor10> =
			call 'erlang':'>='
			    (N, 1)
		    in  call 'erlang':'and'
			    (_cor9, _cor10) ->
	      let <_cor11> =
		  %% Line 402
		  call 'erlang':'-'
		      (N, 1)
	      in  %% Line 402
		  apply 'process_split_params'/6
		      (T, C, U, _cor11, 'false', G)
	  %% Line 403
	  <[{'parts','infinity'}|T],C,U,_X_L,_X_S,G> when 'true' ->
	      %% Line 404
	      apply 'process_split_params'/6
		  (T, C, U, -1, 'false', G)
	  %% Line 405
	  <[{'parts',_cor20}|_cor21],_cor22,_cor23,_cor24,_cor25,_cor26> when 'true' ->
	      %% Line 406
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 407
	  <['group'|T],C,U,L,S,_X_G> when 'true' ->
	      %% Line 408
	      apply 'process_split_params'/6
		  (T, C, U, L, S, 'true')
	  %% Line 409
	  <['global'|_cor27],_cor28,_cor29,_cor30,_cor31,_cor32> when 'true' ->
	      %% Line 410
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 411
	  <['report_errors'|_cor33],_cor34,_cor35,_cor36,_cor37,_cor38> when 'true' ->
	      %% Line 412
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 413
	  <[{'capture',_cor39,_cor40}|_cor41],_cor42,_cor43,_cor44,_cor45,_cor46> when 'true' ->
	      %% Line 414
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 415
	  <[{'capture',_cor47}|_cor48],_cor49,_cor50,_cor51,_cor52,_cor53> when 'true' ->
	      %% Line 416
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 417
	  <[{'return','iodata'}|T],_X_C,U,L,S,G> when 'true' ->
	      %% Line 418
	      apply 'process_split_params'/6
		  (T, 'iodata', U, L, S, G)
	  %% Line 419
	  <[{'return','list'}|T],_X_C,U,L,S,G> when 'true' ->
	      %% Line 420
	      apply 'process_split_params'/6
		  (T, 'list', U, L, S, G)
	  %% Line 421
	  <[{'return','binary'}|T],_X_C,U,L,S,G> when 'true' ->
	      %% Line 422
	      apply 'process_split_params'/6
		  (T, 'binary', U, L, S, G)
	  %% Line 423
	  <[{'return',_cor54}|_cor55],_cor56,_cor57,_cor58,_cor59,_cor60> when 'true' ->
	      %% Line 424
	      call 'erlang':'throw'
		  ('badopt')
	  %% Line 425
	  <[H|T],C,U,L,S,G> when 'true' ->
	      %% Line 426
	      case apply 'process_split_params'/6
		       (T, C, U, L, S, G) of
		<{NT,NC,NU,NL,NS,NG}> when 'true' ->
		    %% Line 427
		    {[H|NT],NC,NU,NL,NS,NG}
		( <_cor13> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor13})
		  -| ['compiler_generated'] )
	      end
	  ( <_cor19,_cor18,_cor17,_cor16,_cor15,_cor14> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor19,_cor18,_cor17,_cor16,_cor15,_cor14})
		  -| [{'function_name',{'process_split_params',6}}] )
	    -| ['compiler_generated'] )
	end
'apply_mlist'/3 =
    %% Line 429
    fun (_cor2,_cor1,_cor0) ->
	let <_cor3> =
	    %% Line 430
	    apply 'precomp_repl'/1
		(_cor1)
	in  %% Line 430
	    apply 'do_mlist'/5
		(_cor2, _cor2, 0, _cor3, _cor0)
'precomp_repl'/1 =
    %% Line 433
    fun (_cor0) ->
	case ( _cor0
	       -| ['reuse_for_context'] ) of
	  <#{}#> when 'true' ->
	      %% Line 434
	      []
	  %% Line 435
	  <#{#<92>(8,1,'integer',['unsigned'|['big']]),
	     #<103>(8,1,'integer',['unsigned'|['big']]),
	     #<123>(8,1,'integer',['unsigned'|['big']]),
	     #<Rest>('all',8,'binary',['unsigned'|['big']])}#>
	      when try
		    let <_cor1> =
			call 'erlang':'byte_size'
			    (Rest)
		    in  call 'erlang':'>'
			    (_cor1, 0)
		of <Try> ->
		    Try
		catch <T,R> ->
		    'false' ->
	      %% Line 436
	      case apply 'pick_int'/1
		       (Rest) of
		<{NS,#{#<125>(8,1,'integer',['unsigned'|['big']]),
		       #<NRest>('all',8,'binary',['unsigned'|['big']])}#}> when 'true' ->
		    let <_cor3> =
			%% Line 437
			call 'erlang':'list_to_integer'
			    (NS)
		    in  let <_cor4> =
			    %% Line 437
			    apply 'precomp_repl'/1
				(NRest)
			in  %% Line 437
			    [_cor3|_cor4]
		( <_cor2> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor2})
		  -| ['compiler_generated'] )
	      end
	  %% Line 438
	  <#{#<92>(8,1,'integer',['unsigned'|['big']]),
	     #<103>(8,1,'integer',['unsigned'|['big']]),
	     #<Rest>('all',8,'binary',['unsigned'|['big']])}#>
	      when try
		    let <_cor5> =
			call 'erlang':'byte_size'
			    (Rest)
		    in  call 'erlang':'>'
			    (_cor5, 0)
		of <Try> ->
		    Try
		catch <T,R> ->
		    'false' ->
	      %% Line 439
	      case apply 'pick_int'/1
		       (Rest) of
		<{NS,NRest}> when 'true' ->
		    let <_cor7> =
			%% Line 440
			call 'erlang':'list_to_integer'
			    (NS)
		    in  let <_cor8> =
			    %% Line 440
			    apply 'precomp_repl'/1
				(NRest)
			in  %% Line 440
			    [_cor7|_cor8]
		( <_cor6> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor6})
		  -| ['compiler_generated'] )
	      end
	  %% Line 441
	  <#{#<92>(8,1,'integer',['unsigned'|['big']]),
	     #<X>(8,1,'integer',['unsigned'|['big']]),
	     #<Rest>('all',8,'binary',['unsigned'|['big']])}#>
	      when let <_cor9> =
		    call 'erlang':'<'
			(X, 49)
		in  let <_cor10> =
			call 'erlang':'>'
			    (X, 57)
		    in  call 'erlang':'or'
			    (_cor9, _cor10) ->
	      %% Line 443
	      case apply 'precomp_repl'/1
		       (Rest) of
		%% Line 444
		<[BHead|T0]>
		    when call 'erlang':'is_binary'
			  (BHead) ->
		    let <_cor11> =
			%% Line 445
			#{#<X>(8,1,'integer',['unsigned'|['big']]),
			  #<BHead>('all',8,'binary',['unsigned'|['big']])}#
		    in  %% Line 445
			[_cor11|T0]
		%% Line 446
		<Other> when 'true' ->
		    let <_cor12> =
			%% Line 447
			#{#<X>(8,1,'integer',['unsigned'|['big']])}#
		    in  %% Line 447
			[_cor12|Other]
	      end
	  %% Line 449
	  <#{#<92>(8,1,'integer',['unsigned'|['big']]),
	     #<Rest>('all',8,'binary',['unsigned'|['big']])}#>
	      when try
		    let <_cor14> =
			call 'erlang':'byte_size'
			    (Rest)
		    in  call 'erlang':'>'
			    (_cor14, 0)
		of <Try> ->
		    Try
		catch <T,R> ->
		    'false' ->
	      %% Line 450
	      case apply 'pick_int'/1
		       (Rest) of
		<{NS,NRest}> when 'true' ->
		    let <_cor16> =
			%% Line 451
			call 'erlang':'list_to_integer'
			    (NS)
		    in  let <_cor17> =
			    %% Line 451
			    apply 'precomp_repl'/1
				(NRest)
			in  %% Line 451
			    [_cor16|_cor17]
		( <_cor15> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor15})
		  -| ['compiler_generated'] )
	      end
	  %% Line 452
	  <#{#<38>(8,1,'integer',['unsigned'|['big']]),
	     #<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
	      let <_cor18> =
		  %% Line 453
		  apply 'precomp_repl'/1
		      (Rest)
	      in  %% Line 453
		  [0|_cor18]
	  %% Line 454
	  <#{#<X>(8,1,'integer',['unsigned'|['big']]),
	     #<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
	      %% Line 455
	      case apply 'precomp_repl'/1
		       (Rest) of
		%% Line 456
		<[BHead|T0]>
		    when call 'erlang':'is_binary'
			  (BHead) ->
		    let <_cor19> =
			%% Line 457
			#{#<X>(8,1,'integer',['unsigned'|['big']]),
			  #<BHead>('all',8,'binary',['unsigned'|['big']])}#
		    in  %% Line 457
			[_cor19|T0]
		%% Line 458
		<Other> when 'true' ->
		    let <_cor20> =
			%% Line 459
			#{#<X>(8,1,'integer',['unsigned'|['big']])}#
		    in  %% Line 459
			[_cor20|Other]
	      end
	  ( <_cor22> when 'true' ->
		do  primop 'bs_context_to_binary'
			(_cor22)
		    ( primop 'match_fail'
			  ({'function_clause',_cor22})
		      -| [{'function_name',{'precomp_repl',1}}] )
	    -| ['compiler_generated'] )
	end
'pick_int'/1 =
    %% Line 464
    fun (_cor0) ->
	case ( _cor0
	       -| ['reuse_for_context'] ) of
	  <#{#<X>(8,1,'integer',['unsigned'|['big']]),
	     #<R>('all',8,'binary',['unsigned'|['big']])}#>
	      when let <_cor1> =
		    call 'erlang':'>='
			(X, 48)
		in  let <_cor2> =
			call 'erlang':'=<'
			    (X, 57)
		    in  call 'erlang':'and'
			    (_cor1, _cor2) ->
	      %% Line 465
	      case apply 'pick_int'/1
		       (R) of
		<{Found,Rest}> when 'true' ->
		    %% Line 466
		    {[X|Found],Rest}
		( <_cor3> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor3})
		  -| ['compiler_generated'] )
	      end
	  %% Line 467
	  <Bin> when 'true' ->
	      do  primop 'bs_context_to_binary'
		      (Bin)
		  %% Line 468
		  {[],Bin}
	end
'do_mlist'/5 =
    %% Line 470
    fun (_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <_cor18,#{}#,_cor19,_cor20,[]> when 'true' ->
	      %% Line 471
	      []
	  %% Line 472
	  <_cor21,Subject,_cor22,_cor23,[]> when 'true' ->
	      %% Line 473
	      Subject
	  %% Line 474
	  <Whole,Subject,Pos,Repl,[[{MPos,Count}|Sub]|Tail]>
	      when %% Line 475
		call 'erlang':'>'
		    (MPos,
		     Pos) ->
	      let <EatLength> =
		  %% Line 476
		  call 'erlang':'-'
		      (MPos, Pos)
	      in  %% Line 477
		  case ( Subject
			 -| ['reuse_for_context'] ) of
		    <#{#<Untouched>(EatLength,8,'binary',['unsigned'|['big']]),
		       #<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
			let <_cor7> =
			    %% Line 478
			    apply 'do_mlist'/5
				(Whole, Rest, MPos, Repl, %% Line 479
							  [[{MPos,Count}|Sub]|Tail])
			in  %% Line 478
			    [Untouched|_cor7]
		    ( <_cor6> when 'true' ->
			  do  primop 'bs_context_to_binary'
				  (_cor6)
			      primop 'match_fail'
				  ({'badmatch',_cor6})
		      -| ['compiler_generated'] )
		  end
	  %% Line 480
	  <Whole,Subject,Pos,Repl,[[{MPos,Count}|Sub]|Tail]>
	      when %% Line 481
		call 'erlang':'=:='
		    (MPos,
		     Pos) ->
	      %% Line 483
	      case ( Subject
		     -| ['reuse_for_context'] ) of
		<#{#<_cor24>(Count,8,'binary',['unsigned'|['big']]),
		   #<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
		    let <NewData> =
			%% Line 484
			apply 'do_replace'/3
			    (Whole, Repl, [{MPos,Count}|Sub])
		    in  let <_cor11> =
			    %% Line 485
			    call 'erlang':'+'
				(Pos, Count)
			in  let <_cor12> =
				%% Line 485
				apply 'do_mlist'/5
				    (Whole, Rest, _cor11, Repl, Tail)
			    in  %% Line 485
				[NewData|_cor12]
		( <_cor9> when 'true' ->
		      do  primop 'bs_context_to_binary'
			      (_cor9)
			  primop 'match_fail'
			      ({'badmatch',_cor9})
		  -| ['compiler_generated'] )
	      end
	  ( <_cor17,_cor16,_cor15,_cor14,_cor13> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor17,_cor16,_cor15,_cor14,_cor13})
		  -| [{'function_name',{'do_mlist',5}}] )
	    -| ['compiler_generated'] )
	end
'do_replace'/3 =
    %% Line 488
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <_cor17,[Bin|[]],_cor18>
	      when call 'erlang':'is_binary'
		    (Bin) ->
	      %% Line 489
	      Bin
	  %% Line 490
	  <Subject,Repl,SubExprs0> when 'true' ->
	      let <SubExprs> =
		  %% Line 491
		  call 'erlang':'list_to_tuple'
		      (SubExprs0)
	      in  %% Line 492
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor6) ->
				case _cor6 of
				  <[%% Line 510
				    Part|_cor5]> when 'true' ->
				      let <_cor12> =
					  case Part of
					    %% Line 493
					    <N>
						when call 'erlang':'is_integer'
						      (Part) ->
						%% Line 494
						case <> of
						  %% Line 495
						  <>
						      when try
							    let <_cor7> =
								call 'erlang':'tuple_size'
								    (SubExprs)
							    in  call 'erlang':'=<'
								    (_cor7, N)
							of <Try> ->
							    Try
							catch <T,R> ->
							    'false' ->
						      %% Line 496
						      #{}#
						  %% Line 497
						  <> when 'true' ->
						      let <_cor8> =
							  %% Line 498
							  call 'erlang':'+'
							      (N, 1)
						      in  %% Line 498
							  case call 'erlang':'element'
								   (_cor8, SubExprs) of
							    <{SPos,SLen}> when 'true' ->
								%% Line 499
								case <> of
								  %% Line 500
								  <>
								      when call 'erlang':'<'
									    (SPos,
									     0) ->
								      %% Line 501
								      #{}#
								  %% Line 502
								  <> when 'true' ->
								      %% Line 503
								      case %% Line 504
									   ( Subject
									     -| ['reuse_for_context'] ) of
									<#{#<_cor19>(SPos,8,'binary',['unsigned'|['big']]),
									   #<Res>(SLen,8,'binary',['unsigned'|['big']]),
									   #<_cor20>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
									    %% Line 505
									    Res
									( <_cor10> when 'true' ->
									      do  primop 'bs_context_to_binary'
										      (_cor10)
										  primop 'match_fail'
										      ({'badmatch',_cor10})
									  -| ['compiler_generated'] )
								      end
								end
							    ( <_cor9> when 'true' ->
								  primop 'match_fail'
								      ({'badmatch',_cor9})
							      -| ['compiler_generated'] )
							  end
						end
					    %% Line 508
					    <Other> when 'true' ->
						%% Line 509
						Other
					  end
				      in  let <_cor13> =
					      %% Line 510
					      apply 'lc$^0'/1
						  (_cor5)
					  in  ( [_cor12|_cor13]
						-| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_cor6> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor6})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (%% Line 510
			     Repl)
		    -| ['list_comprehension'] )
	end
'check_for_unicode'/2 =
    %% Line 513
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <{'re_pattern',_cor4,1,_cor5,_cor6},_cor7> when 'true' ->
	      %% Line 514
	      'true'
	  %% Line 515
	  <{'re_pattern',_cor8,0,_cor9,_cor10},_cor11> when 'true' ->
	      %% Line 516
	      'false'
	  %% Line 517
	  <_cor12,L> when 'true' ->
	      %% Line 518
	      call 'lists':'member'
		  ('unicode', L)
	end
'check_for_crlf'/2 =
    %% Line 520
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <{'re_pattern',_cor5,_cor6,1,_cor7},_cor8> when 'true' ->
	      %% Line 521
	      'true'
	  %% Line 522
	  <{'re_pattern',_cor9,_cor10,0,_cor11},_cor12> when 'true' ->
	      %% Line 523
	      'false'
	  %% Line 524
	  <_cor13,L> when 'true' ->
	      %% Line 525
	      case call 'lists':'keysearch'
		       ('newline', 1, L) of
		%% Line 526
		<{'value',{'newline','any'}}> when 'true' ->
		    'true'
		%% Line 527
		<{'value',{'newline','crlf'}}> when 'true' ->
		    'true'
		%% Line 528
		<{'value',{'newline','anycrlf'}}> when 'true' ->
		    'true'
		%% Line 529
		<_cor14> when 'true' ->
		    'false'
	      end
	end
'process_parameters'/6 =
    %% Line 546
    fun (_cor5,_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor5,_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <[],InitialOffset,SelectReturn,ConvertReturn,_cor19,_cor20> when 'true' ->
	      %% Line 547
	      {[],InitialOffset,SelectReturn,ConvertReturn}
	  %% Line 548
	  <[{'offset',N}|T],_X_Init0,Select0,Return0,CC,RE> when 'true' ->
	      %% Line 549
	      apply 'process_parameters'/6
		  (T, N, Select0, Return0, CC, RE)
	  %% Line 550
	  <['global'|T],Init0,Select0,Return0,CC,RE> when 'true' ->
	      %% Line 551
	      apply 'process_parameters'/6
		  (T, Init0, Select0, Return0, CC, RE)
	  %% Line 552
	  <[{'capture',Values,Type}|T],Init0,Select0,_X_Return0,CC,RE> when 'true' ->
	      %% Line 553
	      apply 'process_parameters'/6
		  ([{'capture',Values}|T], Init0, Select0, Type, CC, RE)
	  %% Line 554
	  <[{'capture',Values}|T],Init0,Select0,Return0,CC,RE> when 'true' ->
	      %% Line 556
	      case %% Line 557
		   apply 'process_parameters'/6
		       (T, Init0, Select0, Return0, CC, RE) of
		<{NewTail,Init1,Select1,Return1}> when 'true' ->
		    %% Line 558
		    case Select1 of
		      %% Line 559
		      <'false'> when 'true' ->
			  %% Line 560
			  case Values of
			    %% Line 561
			    <'all'> when 'true' ->
				%% Line 562
				{[{'capture','all'}|NewTail],Init1,'all',Return0}
			    %% Line 563
			    <'all_names'> when 'true' ->
				%% Line 564
				case call 're':'inspect'
					 (RE, 'namelist') of
				  %% Line 565
				  <{'namelist',[]}> when 'true' ->
				      %% Line 566
				      {[{'capture','first'}|NewTail],Init1,'none',Return0}
				  %% Line 567
				  <{'namelist',List}> when 'true' ->
				      %% Line 568
				      {[{'capture',[0|List]}|NewTail],Init1,'stripfirst',Return0}
				  ( <_cor7> when 'true' ->
					primop 'match_fail'
					    ({'case_clause',_cor7})
				    -| ['compiler_generated'] )
				end
			    %% Line 570
			    <'first'> when 'true' ->
				%% Line 571
				{[{'capture','first'}|NewTail],Init1,'all',Return0}
			    %% Line 572
			    <'all_but_first'> when 'true' ->
				%% Line 573
				{[{'capture','all'}|NewTail],Init1,'stripfirst',Return0}
			    %% Line 574
			    <'none'> when 'true' ->
				%% Line 575
				{[{'capture','first'}|NewTail],Init1,'none',Return0}
			    %% Line 576
			    <[]> when 'true' ->
				%% Line 577
				{[{'capture','first'}|NewTail],Init1,'none',Return0}
			    %% Line 578
			    <List>
				when call 'erlang':'is_list'
				      (Values) ->
				%% Line 579
				{[{'capture',[0|List]}|NewTail],%% Line 580
								Init1,%% Line 580
								      'stripfirst',%% Line 580
										   Return0}
			    %% Line 581
			    <_cor21> when 'true' ->
				%% Line 582
				call 'erlang':'throw'
				    ('badlist')
			  end
		      %% Line 584
		      <_cor22> when 'true' ->
			  %% Line 586
			  {NewTail,Init1,Select1,Return1}
		    end
		( <_cor6> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor6})
		  -| ['compiler_generated'] )
	      end
	  %% Line 588
	  <[H|T],Init0,Select0,Return0,'true',RE> when 'true' ->
	      %% Line 589
	      case apply 'copt'/1
		       (H) of
		%% Line 590
		<'true'> when 'true' ->
		    %% Line 591
		    apply 'process_parameters'/6
			(T, Init0, Select0, Return0, 'true', RE)
		%% Line 592
		<'false'> when 'true' ->
		    %% Line 593
		    case %% Line 594
			 apply 'process_parameters'/6
			     (T, Init0, Select0, Return0, 'true', RE) of
		      <{NewT,Init,Select,Return}> when 'true' ->
			  %% Line 595
			  {[H|NewT],Init,Select,Return}
		      ( <_cor10> when 'true' ->
			    primop 'match_fail'
				({'badmatch',_cor10})
			-| ['compiler_generated'] )
		    end
		( <_cor11> when 'true' ->
		      primop 'match_fail'
			  ({'case_clause',_cor11})
		  -| ['compiler_generated'] )
	      end
	  %% Line 597
	  <[H|T],Init0,Select0,Return0,'false',RE> when 'true' ->
	      %% Line 598
	      case %% Line 599
		   apply 'process_parameters'/6
		       (T, Init0, Select0, Return0, 'false', RE) of
		<{NewT,Init,Select,Return}> when 'true' ->
		    %% Line 600
		    {[H|NewT],Init,Select,Return}
		( <_cor12> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor12})
		  -| ['compiler_generated'] )
	      end
	  %% Line 601
	  <_cor23,_cor24,_cor25,_cor26,_cor27,_cor28> when 'true' ->
	      %% Line 602
	      call 'erlang':'throw'
		  ('badlist')
	end
'postprocess'/5 =
    %% Line 604
    fun (_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <{'match',[]},_cor17,_cor18,_cor19,_cor20> when 'true' ->
	      %% Line 605
	      'nomatch'
	  %% Line 606
	  <{'match',_cor21},'none',_cor22,_cor23,_cor24> when 'true' ->
	      %% Line 607
	      'match'
	  %% Line 608
	  <{'match',M},Any,'binary',Flat,Uni> when 'true' ->
	      let <_cor5> =
		  %% Line 609
		  apply 'postprocess'/5
		      ({'match',M}, Any, 'index', Flat, Uni)
	      in  %% Line 609
		  apply 'binarify'/2
		      (_cor5, Flat)
	  %% Line 610
	  <{'match',M},Any,'list',Flat,Uni> when 'true' ->
	      let <_cor6> =
		  %% Line 611
		  apply 'postprocess'/5
		      ({'match',M}, Any, 'index', Flat, Uni)
	      in  %% Line 611
		  apply 'listify'/3
		      (_cor6, Flat, Uni)
	  %% Line 612
	  <{'match',M},'all','index',_cor25,_cor26> when 'true' ->
	      %% Line 613
	      {'match',M}
	  %% Line 614
	  <{'match',M},'false','index',_cor27,_cor28> when 'true' ->
	      %% Line 615
	      {'match',M}
	  %% Line 616
	  <{'match',M},'stripfirst','index',_cor29,_cor30> when 'true' ->
	      let <_cor11> =
		  %% Line 617
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor9) ->
				case _cor9 of
				  <[[_cor31|T]|_cor8]> when 'true' ->
				      let <_cor10> =
					  apply 'lc$^0'/1
					      (_cor8)
				      in  ( [T|_cor10]
					    -| ['compiler_generated'] )
				  ( <[_cor7|_cor8]> when 'true' ->
					apply 'lc$^0'/1
					    (_cor8)
				    -| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_cor9> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor9})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (M)
		    -| ['list_comprehension'] )
	      in  %% Line 617
		  {'match',_cor11}
	  ( <_cor16,_cor15,_cor14,_cor13,_cor12> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor16,_cor15,_cor14,_cor13,_cor12})
		  -| [{'function_name',{'postprocess',5}}] )
	    -| ['compiler_generated'] )
	end
'binarify'/2 =
    %% Line 619
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <{'match',M},Flat> when 'true' ->
	      let <_cor14> =
		  %% Line 620
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor4) ->
				case _cor4 of
				  <[%% Line 626
				    One|_cor3]> when 'true' ->
				      let <_cor12> =
					  ( letrec
						'lc$^1'/1 =
						    fun (_cor7) ->
							case _cor7 of
							  <[%% Line 626
							    {I,L}|_cor6]> when 'true' ->
							      let <_cor10> =
								  case <I,L> of
								    %% Line 621
								    <-1,0> when 'true' ->
									%% Line 622
									#{}#
								    %% Line 623
								    <SPos,SLen> when 'true' ->
									%% Line 624
									case ( Flat
									       -| ['reuse_for_context'] ) of
									  <#{#<_cor17>(SPos,8,'binary',['unsigned'|['big']]),
									     #<Res>(SLen,8,'binary',['unsigned'|['big']]),
									     #<_cor18>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
									      %% Line 625
									      Res
									  ( <_cor8> when 'true' ->
										do  primop 'bs_context_to_binary'
											(_cor8)
										    primop 'match_fail'
											({'badmatch',_cor8})
									    -| ['compiler_generated'] )
									end
								  end
							      in  let <_cor11> =
								      %% Line 626
								      apply 'lc$^1'/1
									  (_cor6)
								  in  ( [_cor10|_cor11]
									-| ['compiler_generated'] )
							  ( <[_cor5|_cor6]> when 'true' ->
								%% Line 626
								apply 'lc$^1'/1
								    (_cor6)
							    -| ['compiler_generated'] )
							  <[]> when 'true' ->
							      []
							  ( <_cor7> when 'true' ->
								( primop 'match_fail'
								      ({'function_clause',_cor7})
								  -| [{'function_name',{'lc$^1',1}}] )
							    -| ['compiler_generated'] )
							end
					    in  apply 'lc$^1'/1
						    (%% Line 626
						     One)
					    -| ['list_comprehension'] )
				      in  let <_cor13> =
					      %% Line 626
					      apply 'lc$^0'/1
						  (_cor3)
					  in  ( [_cor12|_cor13]
						-| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_cor4> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor4})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (%% Line 626
			     M)
		    -| ['list_comprehension'] )
	      in  %% Line 620
		  {'match',_cor14}
	  ( <_cor16,_cor15> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor16,_cor15})
		  -| [{'function_name',{'binarify',2}}] )
	    -| ['compiler_generated'] )
	end
'listify'/3 =
    %% Line 627
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <{'match',M},Flat,Uni> when 'true' ->
	      let <_cor18> =
		  %% Line 628
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor5) ->
				case _cor5 of
				  <[%% Line 641
				    One|_cor4]> when 'true' ->
				      let <_cor16> =
					  ( letrec
						'lc$^1'/1 =
						    fun (_cor8) ->
							case _cor8 of
							  <[%% Line 641
							    {I,L}|_cor7]> when 'true' ->
							      let <_cor14> =
								  case <I,L> of
								    %% Line 629
								    <_cor22,0> when 'true' ->
									%% Line 630
									[]
								    %% Line 631
								    <SPos,SLen> when 'true' ->
									%% Line 632
									case Uni of
									  %% Line 633
									  <'true'> when 'true' ->
									      %% Line 634
									      case ( Flat
										     -| ['reuse_for_context'] ) of
										<#{#<_cor23>(SPos,8,'binary',['unsigned'|['big']]),
										   #<Res>(SLen,8,'binary',['unsigned'|['big']]),
										   #<_cor24>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
										    %% Line 635
										    call 'unicode':'characters_to_list'
											(Res, 'unicode')
										( <_cor9> when 'true' ->
										      do  primop 'bs_context_to_binary'
											      (_cor9)
											  primop 'match_fail'
											      ({'badmatch',_cor9})
										  -| ['compiler_generated'] )
									      end
									  %% Line 636
									  <'false'> when 'true' ->
									      let <Start> =
										  %% Line 637
										  call 'erlang':'+'
										      (SPos, 1)
									      in  let <End> =
										      %% Line 638
										      call 'erlang':'+'
											  (SPos, SLen)
										  in  %% Line 639
										      call 'erlang':'binary_to_list'
											  (Flat, Start, End)
									  ( <_cor12> when 'true' ->
										primop 'match_fail'
										    ({'case_clause',_cor12})
									    -| ['compiler_generated'] )
									end
								  end
							      in  let <_cor15> =
								      %% Line 641
								      apply 'lc$^1'/1
									  (_cor7)
								  in  ( [_cor14|_cor15]
									-| ['compiler_generated'] )
							  ( <[_cor6|_cor7]> when 'true' ->
								%% Line 641
								apply 'lc$^1'/1
								    (_cor7)
							    -| ['compiler_generated'] )
							  <[]> when 'true' ->
							      []
							  ( <_cor8> when 'true' ->
								( primop 'match_fail'
								      ({'function_clause',_cor8})
								  -| [{'function_name',{'lc$^1',1}}] )
							    -| ['compiler_generated'] )
							end
					    in  apply 'lc$^1'/1
						    (%% Line 641
						     One)
					    -| ['list_comprehension'] )
				      in  let <_cor17> =
					      %% Line 641
					      apply 'lc$^0'/1
						  (_cor4)
					  in  ( [_cor16|_cor17]
						-| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_cor5> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor5})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (%% Line 641
			     M)
		    -| ['list_comprehension'] )
	      in  %% Line 628
		  {'match',_cor18}
	  ( <_cor21,_cor20,_cor19> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor21,_cor20,_cor19})
		  -| [{'function_name',{'listify',3}}] )
	    -| ['compiler_generated'] )
	end
'ubinarify'/2 =
    %% Line 643
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <{'match',M},Flat> when 'true' ->
	      let <_cor9> =
		  %% Line 644
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor4) ->
				case _cor4 of
				  <[%% Line 650
				    {I,L}|_cor3]> when 'true' ->
				      let <_cor7> =
					  case <I,L> of
					    %% Line 645
					    <-1,0> when 'true' ->
						%% Line 646
						#{}#
					    %% Line 647
					    <SPos,SLen> when 'true' ->
						%% Line 648
						case ( Flat
						       -| ['reuse_for_context'] ) of
						  <#{#<_cor12>(SPos,8,'binary',['unsigned'|['big']]),
						     #<Res>(SLen,8,'binary',['unsigned'|['big']]),
						     #<_cor13>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
						      %% Line 649
						      Res
						  ( <_cor5> when 'true' ->
							do  primop 'bs_context_to_binary'
								(_cor5)
							    primop 'match_fail'
								({'badmatch',_cor5})
						    -| ['compiler_generated'] )
						end
					  end
				      in  let <_cor8> =
					      %% Line 650
					      apply 'lc$^0'/1
						  (_cor3)
					  in  ( [_cor7|_cor8]
						-| ['compiler_generated'] )
				  ( <[_cor2|_cor3]> when 'true' ->
					%% Line 650
					apply 'lc$^0'/1
					    (_cor3)
				    -| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_cor4> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor4})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (%% Line 650
			     M)
		    -| ['list_comprehension'] )
	      in  %% Line 644
		  {'match',_cor9}
	  %% Line 651
	  <Else,_cor14> when 'true' ->
	      %% Line 652
	      Else
	end
'ulistify'/2 =
    %% Line 653
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <{'match',M},Flat> when 'true' ->
	      let <_cor9> =
		  %% Line 654
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor4) ->
				case _cor4 of
				  <[%% Line 660
				    {I,L}|_cor3]> when 'true' ->
				      let <_cor7> =
					  case <I,L> of
					    %% Line 655
					    <_cor12,0> when 'true' ->
						%% Line 656
						[]
					    %% Line 657
					    <SPos,SLen> when 'true' ->
						%% Line 658
						case ( Flat
						       -| ['reuse_for_context'] ) of
						  <#{#<_cor13>(SPos,8,'binary',['unsigned'|['big']]),
						     #<Res>(SLen,8,'binary',['unsigned'|['big']]),
						     #<_cor14>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
						      %% Line 659
						      call 'unicode':'characters_to_list'
							  (Res, 'unicode')
						  ( <_cor5> when 'true' ->
							do  primop 'bs_context_to_binary'
								(_cor5)
							    primop 'match_fail'
								({'badmatch',_cor5})
						    -| ['compiler_generated'] )
						end
					  end
				      in  let <_cor8> =
					      %% Line 660
					      apply 'lc$^0'/1
						  (_cor3)
					  in  ( [_cor7|_cor8]
						-| ['compiler_generated'] )
				  ( <[_cor2|_cor3]> when 'true' ->
					%% Line 660
					apply 'lc$^0'/1
					    (_cor3)
				    -| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_cor4> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor4})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (%% Line 660
			     M)
		    -| ['list_comprehension'] )
	      in  %% Line 654
		  {'match',_cor9}
	  %% Line 661
	  <Else,_cor15> when 'true' ->
	      %% Line 662
	      Else
	end
'process_uparams'/2 =
    %% Line 664
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <['global'|_X_T],_X_RetType> when 'true' ->
	      %% Line 665
	      call 'erlang':'throw'
		  ('false')
	  %% Line 666
	  <[{'capture',Values,Type}|T],_X_OldType> when 'true' ->
	      %% Line 667
	      apply 'process_uparams'/2
		  ([{'capture',Values}|T], Type)
	  %% Line 668
	  <[H|T],Type> when 'true' ->
	      %% Line 669
	      case apply 'process_uparams'/2
		       (T, Type) of
		<{NL,NType}> when 'true' ->
		    %% Line 670
		    {[H|NL],NType}
		( <_cor2> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor2})
		  -| ['compiler_generated'] )
	      end
	  %% Line 671
	  <[],Type> when 'true' ->
	      %% Line 672
	      {[],Type}
	  ( <_cor4,_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor4,_cor3})
		  -| [{'function_name',{'process_uparams',2}}] )
	    -| ['compiler_generated'] )
	end
'ucompile'/2 =
    %% Line 675
    fun (_cor1,_cor0) ->
	%% Line 676
	try
	    let <_cor2> =
		%% Line 677
		call 'unicode':'characters_to_binary'
		    (_cor1, 'unicode')
	    in  %% Line 677
		call 're':'compile'
		    (_cor2, _cor0)
	of <_cor3> ->
	    _cor3
	catch <_cor6,_cor5,_cor4> ->
	    case <_cor6,_cor5,_cor4> of
	      %% Line 679
	      <'error',AnyError,_cor11> when 'true' ->
		  let <_cor7> =
		      catch
			  %% Line 681
			  call 'erlang':'error'
			      ('new_stacktrace', %% Line 682
						 [_cor1|[_cor0|[]]])
		  in  %% Line 680
		      case _cor7 of
			<{'EXIT',{'new_stacktrace',[{Mod,_cor12,L,Loc}|Rest]}}> when 'true' ->
			    %% Line 683
			    call 'erlang':'raise'
				('error', AnyError, [{Mod,'compile',L,Loc}|Rest])
			( <_cor8> when 'true' ->
			      primop 'match_fail'
				  ({'badmatch',_cor8})
			  -| ['compiler_generated'] )
		      end
	      ( <_cor6,_cor5,_cor4> when 'true' ->
		    primop 'raise'
			(_cor4, _cor5)
		-| ['compiler_generated'] )
	    end
'urun'/3 =
    %% Line 687
    fun (_cor2,_cor1,_cor0) ->
	%% Line 688
	try
	    %% Line 689
	    apply 'urun2'/3
		(_cor2, _cor1, _cor0)
	of <_cor3> ->
	    _cor3
	catch <_cor6,_cor5,_cor4> ->
	    case <_cor6,_cor5,_cor4> of
	      %% Line 691
	      <'error',AnyError,_cor12> when 'true' ->
		  let <_cor7> =
		      catch
			  %% Line 693
			  call 'erlang':'error'
			      ('new_stacktrace', %% Line 694
						 [_cor2|[_cor1|[_cor0|[]]]])
		  in  %% Line 692
		      case _cor7 of
			<{'EXIT',{'new_stacktrace',[{Mod,_cor13,L,Loc}|Rest]}}> when 'true' ->
			    %% Line 695
			    call 'erlang':'raise'
				('error', AnyError, [{Mod,'run',L,Loc}|Rest])
			( <_cor8> when 'true' ->
			      primop 'match_fail'
				  ({'badmatch',_cor8})
			  -| ['compiler_generated'] )
		      end
	      ( <_cor6,_cor5,_cor4> when 'true' ->
		    primop 'raise'
			(_cor4, _cor5)
		-| ['compiler_generated'] )
	    end
'urun2'/3 =
    %% Line 698
    fun (_cor2,_cor1,_cor0) ->
	let <_cor3> =
	    catch
		%% Line 699
		apply 'process_uparams'/2
		    (_cor0, 'index')
	in  let <Options,RetType> =
		%% Line 699
		case _cor3 of
		  %% Line 700
		  <{A,B}> when 'true' ->
		      %% Line 701
		      <A,B>
		  %% Line 702
		  <_cor16> when 'true' ->
		      %% Line 703
		      <_cor0,'false'>
		end
	    in  let <Subject> =
		    %% Line 705
		    call 'unicode':'characters_to_binary'
			(_cor2, 'unicode')
		in  let <_cor9> =
			%% Line 706
			case _cor1 of
			  %% Line 707
			  <BinRE>
			      when call 'erlang':'is_binary'
				    (_cor1) ->
			      %% Line 708
			      BinRE
			  %% Line 709
			  <ReCompiled = {'re_pattern',_cor17,_cor18,_cor19,_cor20}> when 'true' ->
			      %% Line 710
			      ReCompiled
			  %% Line 711
			  <ListRE> when 'true' ->
			      %% Line 712
			      call 'unicode':'characters_to_binary'
				  (ListRE, 'unicode')
			end
		    in  let <Ret> =
			    %% Line 714
			    call 're':'run'
				(Subject, _cor9, Options)
			in  %% Line 715
			    case RetType of
			      %% Line 716
			      <'binary'> when 'true' ->
				  %% Line 717
				  apply 'ubinarify'/2
				      (Ret, Subject)
			      %% Line 718
			      <'list'> when 'true' ->
				  %% Line 719
				  apply 'ulistify'/2
				      (Ret, Subject)
			      %% Line 720
			      <_cor21> when 'true' ->
				  %% Line 721
				  Ret
			    end
'grun'/3 =
    %% Line 727
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <Subject,RE,{Options,NeedClean}> when 'true' ->
	      %% Line 728
	      try
		  %% Line 729
		  apply 'grun2'/3
		      (Subject, RE, {Options,NeedClean})
	      of <_cor3> ->
		  _cor3
	      catch <_cor6,_cor5,_cor4> ->
		  case <_cor6,_cor5,_cor4> of
		    %% Line 731
		    <'error',AnyError,_cor18> when 'true' ->
			let <_cor7> =
			    catch
				%% Line 733
				call 'erlang':'error'
				    ('new_stacktrace', %% Line 734
						       [Subject|[RE|[Options|[]]]])
			in  %% Line 732
			    case _cor7 of
			      <{'EXIT',{'new_stacktrace',[{Mod,_cor19,L,Loc}|Rest]}}> when 'true' ->
				  %% Line 735
				  call 'erlang':'raise'
				      ('error', AnyError, [{Mod,'run',L,Loc}|Rest])
			      ( <_cor8> when 'true' ->
				    primop 'match_fail'
					({'badmatch',_cor8})
				-| ['compiler_generated'] )
			    end
		    ( <_cor6,_cor5,_cor4> when 'true' ->
			  primop 'raise'
			      (_cor4, _cor5)
		      -| ['compiler_generated'] )
		  end
	  %% Line 737
	  <Subject,RE,{Options,NeedClean,OrigRE}> when 'true' ->
	      %% Line 738
	      try
		  %% Line 739
		  apply 'grun2'/3
		      (Subject, RE, {Options,NeedClean})
	      of <_cor9> ->
		  _cor9
	      catch <_cor12,_cor11,_cor10> ->
		  case <_cor12,_cor11,_cor10> of
		    %% Line 741
		    <'error',AnyError,_cor20> when 'true' ->
			let <_cor13> =
			    catch
				%% Line 743
				call 'erlang':'error'
				    ('new_stacktrace', %% Line 744
						       [Subject|[OrigRE|[Options|[]]]])
			in  %% Line 742
			    case _cor13 of
			      <{'EXIT',{'new_stacktrace',[{Mod,_cor21,L,Loc}|Rest]}}> when 'true' ->
				  %% Line 745
				  call 'erlang':'raise'
				      ('error', AnyError, [{Mod,'run',L,Loc}|Rest])
			      ( <_cor14> when 'true' ->
				    primop 'match_fail'
					({'badmatch',_cor14})
				-| ['compiler_generated'] )
			    end
		    ( <_cor12,_cor11,_cor10> when 'true' ->
			  primop 'raise'
			      (_cor10, _cor11)
		      -| ['compiler_generated'] )
		  end
	  ( <_cor17,_cor16,_cor15> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor17,_cor16,_cor15})
		  -| [{'function_name',{'grun',3}}] )
	    -| ['compiler_generated'] )
	end
'grun2'/3 =
    %% Line 748
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <Subject,RE,{Options,NeedClean}> when 'true' ->
	      let <Unicode> =
		  %% Line 749
		  apply 'check_for_unicode'/2
		      (RE, Options)
	      in  let <CRLF> =
		      %% Line 750
		      apply 'check_for_crlf'/2
			  (RE, Options)
		  in  let <FlatSubject> =
			  %% Line 751
			  apply 'to_binary'/2
			      (Subject, Unicode)
		      in  %% Line 752
			  apply 'do_grun'/6
			      (FlatSubject, Subject, Unicode, CRLF, RE, {Options,NeedClean})
	  ( <_cor8,_cor7,_cor6> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor8,_cor7,_cor6})
		  -| [{'function_name',{'grun2',3}}] )
	    -| ['compiler_generated'] )
	end
'do_grun'/6 =
    %% Line 754
    fun (_cor5,_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor5,_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <FlatSubject,Subject,Unicode,CRLF,RE,{Options0,NeedClean}> when 'true' ->
	      let <_cor6> =
		  catch
		      %% Line 758
		      apply 'process_parameters'/6
			  (Options0, 0, 'false', 'index', NeedClean, RE)
	      in  let <_cor8> =
		      %% Line 757
		      case _cor6 of
			%% Line 759
			<'badlist'> when 'true' ->
			    %% Line 760
			    call 'erlang':'error'
				('badarg', [Subject|[RE|[Options0|[]]]])
			%% Line 761
			<CorrectReturn> when 'true' ->
			    %% Line 762
			    CorrectReturn
		      end
		  in  %% Line 756
		      case _cor8 of
			<{StrippedOptions,InitialOffset,SelectReturn,ConvertReturn}> when 'true' ->
			    %% Line 764
			    try
				let <_cor10> =
				    %% Line 766
				    call 'erlang':'byte_size'
					(FlatSubject)
				in  let <_cor11> =
					%% Line 765
					apply 'loopexec'/7
					    (FlatSubject, RE, InitialOffset, _cor10, %% Line 767
										     Unicode, %% Line 767
											      CRLF, %% Line 767
												    StrippedOptions)
				    in  %% Line 765
					apply 'postprocess'/5
					    (_cor11, %% Line 768
						     SelectReturn, %% Line 768
								   ConvertReturn, %% Line 768
										  FlatSubject, %% Line 768
											       Unicode)
			    of <_cor12> ->
				_cor12
			    catch <_cor15,_cor14,_cor13> ->
				case <_cor15,_cor14,_cor13> of
				  %% Line 770
				  <'throw',ErrTuple,_cor22> when 'true' ->
				      %% Line 771
				      ErrTuple
				  ( <_cor15,_cor14,_cor13> when 'true' ->
					primop 'raise'
					    (_cor13, _cor14)
				    -| ['compiler_generated'] )
				end
			( <_cor9> when 'true' ->
			      primop 'match_fail'
				  ({'badmatch',_cor9})
			  -| ['compiler_generated'] )
		      end
	  ( <_cor21,_cor20,_cor19,_cor18,_cor17,_cor16> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor21,_cor20,_cor19,_cor18,_cor17,_cor16})
		  -| [{'function_name',{'do_grun',6}}] )
	    -| ['compiler_generated'] )
	end
'loopexec'/7 =
    %% Line 774
    fun (_cor6,_cor5,_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor6,_cor5,_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <_cor29,_cor30,X,Y,_cor31,_cor32,_cor33>
	      when call 'erlang':'>'
		    (X,
		     Y) ->
	      %% Line 775
	      {'match',[]}
	  %% Line 776
	  <Subject,RE,X,Y,Unicode,CRLF,Options> when 'true' ->
	      let <_cor7> =
		  %% Line 777
		  [{'offset',X}|Options]
	      in  %% Line 777
		  case call 're':'run'
			   (Subject, RE, _cor7) of
		    %% Line 778
		    <{'error',Err}> when 'true' ->
			%% Line 779
			call 'erlang':'throw'
			    ({'error',Err})
		    %% Line 780
		    <'nomatch'> when 'true' ->
			%% Line 781
			{'match',[]}
		    %% Line 782
		    <{'match',[{A,B}|More]}> when 'true' ->
			let <_cor19> =
			    %% Line 784
			    case <> of
			      %% Line 785
			      <>
				  when call 'erlang':'>'
					(B,
					 0) ->
				  let <_cor8> =
				      %% Line 786
				      call 'erlang':'+'
					  (A, B)
				  in  %% Line 786
				      apply 'loopexec'/7
					  (Subject, RE, _cor8, Y, Unicode, CRLF, Options)
			      %% Line 787
			      <> when 'true' ->
				  let <_cor9> =
				      %% Line 789
				      [{'offset',X}|%% Line 790
						    ['notempty_atstart'|['anchored'|Options]]]
				  in  let <_cor11> =
					  %% Line 789
					  case call 're':'run'
						   (Subject, RE, _cor9) of
					    %% Line 791
					    <'nomatch'> when 'true' ->
						%% Line 792
						{'match',[]}
					    %% Line 793
					    <{'match',Other}> when 'true' ->
						%% Line 794
						{'match',Other}
					    ( <_cor10> when 'true' ->
						  primop 'match_fail'
						      ({'case_clause',_cor10})
					      -| ['compiler_generated'] )
					  end
				      in  %% Line 788
					  case _cor11 of
					    <{'match',M}> when 'true' ->
						let <_cor14> =
						    %% Line 796
						    case M of
						      %% Line 797
						      <[{_cor34,NStep}|_cor35]>
							  when call 'erlang':'>'
								(NStep,
								 0) ->
							  %% Line 798
							  call 'erlang':'+'
							      (A, NStep)
						      %% Line 799
						      <_cor36> when 'true' ->
							  %% Line 800
							  apply 'forward'/5
							      (Subject, A, 1, Unicode, CRLF)
						    end
						in  %% Line 802
						    case apply 'loopexec'/7
							     (Subject, RE, _cor14, Y, %% Line 803
										      Unicode, %% Line 803
											       CRLF, %% Line 803
												     Options) of
						      <{'match',MM}> when 'true' ->
							  %% Line 804
							  case M of
							    %% Line 805
							    <[]> when 'true' ->
								%% Line 806
								{'match',MM}
							    %% Line 807
							    <_cor37> when 'true' ->
								%% Line 808
								{'match',[M|MM]}
							  end
						      ( <_cor16> when 'true' ->
							    primop 'match_fail'
								({'badmatch',_cor16})
							-| ['compiler_generated'] )
						    end
					    ( <_cor12> when 'true' ->
						  primop 'match_fail'
						      ({'badmatch',_cor12})
					      -| ['compiler_generated'] )
					  end
			    end
			in  %% Line 783
			    case _cor19 of
			      <{'match',Rest}> when 'true' ->
				  %% Line 811
				  {'match',[[{A,B}|More]|Rest]}
			      ( <_cor20> when 'true' ->
				    primop 'match_fail'
					({'badmatch',_cor20})
				-| ['compiler_generated'] )
			    end
		    ( <_cor21> when 'true' ->
			  primop 'match_fail'
			      ({'case_clause',_cor21})
		      -| ['compiler_generated'] )
		  end
	end
'forward'/5 =
    %% Line 814
    fun (_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <_X_Chal,A,0,_cor14,_cor15> when 'true' ->
	      %% Line 815
	      A
	  %% Line 816
	  <Chal,A,N,U,'true'> when 'true' ->
	      %% Line 817
	      case Chal of
		<#{#<_cor16>(A,8,'binary',['unsigned'|['big']]),
		   #<Tl>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
		    %% Line 818
		    case ( Tl
			   -| ['reuse_for_context'] ) of
		      %% Line 819
		      <#{#<13>(8,1,'integer',['unsigned'|['big']]),
			 #<10>(8,1,'integer',['unsigned'|['big']]),
			 #<_cor17>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
			  let <_cor7> =
			      %% Line 820
			      call 'erlang':'+'
				  (A, 2)
			  in  let <_cor6> =
				  %% Line 820
				  call 'erlang':'-'
				      (N, 1)
			      in  %% Line 820
				  apply 'forward'/5
				      (Chal, _cor7, _cor6, U, 'true')
		      %% Line 821
		      <_cor18> when 'true' ->
			  %% Line 822
			  apply 'forward2'/5
			      (Chal, A, N, U, 'true')
		    end
		( <_cor5> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor5})
		  -| ['compiler_generated'] )
	      end
	  %% Line 824
	  <Chal,A,N,U,'false'> when 'true' ->
	      %% Line 825
	      apply 'forward2'/5
		  (Chal, A, N, U, 'false')
	  ( <_cor13,_cor12,_cor11,_cor10,_cor9> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor13,_cor12,_cor11,_cor10,_cor9})
		  -| [{'function_name',{'forward',5}}] )
	    -| ['compiler_generated'] )
	end
'forward2'/5 =
    %% Line 827
    fun (_cor4,_cor3,_cor2,_cor1,_cor0) ->
	case <_cor4,_cor3,_cor2,_cor1,_cor0> of
	  <Chal,A,N,'false',CRLF> when 'true' ->
	      let <_cor6> =
		  %% Line 828
		  call 'erlang':'+'
		      (A, 1)
	      in  let <_cor5> =
		      %% Line 828
		      call 'erlang':'-'
			  (N, 1)
		  in  %% Line 828
		      apply 'forward'/5
			  (Chal, _cor6, _cor5, 'false', CRLF)
	  %% Line 829
	  <Chal,A,N,'true',CRLF> when 'true' ->
	      %% Line 830
	      case Chal of
		<#{#<_cor18>(A,8,'binary',['unsigned'|['big']]),
		   #<Tl>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
		    let <_cor9> =
			%% Line 831
			case ( Tl
			       -| ['reuse_for_context'] ) of
			  %% Line 832
			  <#{#<1>(1,1,'integer',['unsigned'|['big']]),
			     #<1>(1,1,'integer',['unsigned'|['big']]),
			     #<0>(1,1,'integer',['unsigned'|['big']]),
			     #<_cor19>(5,1,'integer',['unsigned'|['big']]),
			     #<_cor20>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
			      %% Line 833
			      2
			  %% Line 834
			  <#{#<1>(1,1,'integer',['unsigned'|['big']]),
			     #<1>(1,1,'integer',['unsigned'|['big']]),
			     #<1>(1,1,'integer',['unsigned'|['big']]),
			     #<0>(1,1,'integer',['unsigned'|['big']]),
			     #<_cor21>(4,1,'integer',['unsigned'|['big']]),
			     #<_cor22>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
			      %% Line 835
			      3
			  %% Line 836
			  <#{#<1>(1,1,'integer',['unsigned'|['big']]),
			     #<1>(1,1,'integer',['unsigned'|['big']]),
			     #<1>(1,1,'integer',['unsigned'|['big']]),
			     #<1>(1,1,'integer',['unsigned'|['big']]),
			     #<0>(1,1,'integer',['unsigned'|['big']]),
			     #<_cor23>(3,1,'integer',['unsigned'|['big']]),
			     #<_cor24>('all',8,'binary',['unsigned'|['big']])}#> when 'true' ->
			      %% Line 837
			      4
			  %% Line 838
			  <_cor25> when 'true' ->
			      %% Line 839
			      1
			end
		    in  let <_cor12> =
			    %% Line 841
			    call 'erlang':'+'
				(A, _cor9)
			in  let <_cor11> =
				%% Line 841
				call 'erlang':'-'
				    (N, 1)
			    in  %% Line 841
				apply 'forward'/5
				    (Chal, _cor12, _cor11, 'true', CRLF)
		( <_cor7> when 'true' ->
		      primop 'match_fail'
			  ({'badmatch',_cor7})
		  -| ['compiler_generated'] )
	      end
	  ( <_cor17,_cor16,_cor15,_cor14,_cor13> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor17,_cor16,_cor15,_cor14,_cor13})
		  -| [{'function_name',{'forward2',5}}] )
	    -| ['compiler_generated'] )
	end
'copt'/1 =
    %% Line 843
    fun (_cor0) ->
	case _cor0 of
	  <'caseless'> when 'true' ->
	      %% Line 844
	      'true'
	  %% Line 845
	  <'no_start_optimize'> when 'true' ->
	      %% Line 846
	      'true'
	  %% Line 847
	  <'never_utf'> when 'true' ->
	      %% Line 848
	      'true'
	  %% Line 849
	  <'ucp'> when 'true' ->
	      %% Line 850
	      'true'
	  %% Line 851
	  <'dollar_endonly'> when 'true' ->
	      %% Line 852
	      'true'
	  %% Line 853
	  <'dotall'> when 'true' ->
	      %% Line 854
	      'true'
	  %% Line 855
	  <'extended'> when 'true' ->
	      %% Line 856
	      'true'
	  %% Line 857
	  <'firstline'> when 'true' ->
	      %% Line 858
	      'true'
	  %% Line 859
	  <'multiline'> when 'true' ->
	      %% Line 860
	      'true'
	  %% Line 861
	  <'no_auto_capture'> when 'true' ->
	      %% Line 862
	      'true'
	  %% Line 863
	  <'dupnames'> when 'true' ->
	      %% Line 864
	      'true'
	  %% Line 865
	  <'ungreedy'> when 'true' ->
	      %% Line 866
	      'true'
	  %% Line 867
	  <'unicode'> when 'true' ->
	      %% Line 868
	      'true'
	  %% Line 869
	  <_cor2> when 'true' ->
	      %% Line 870
	      'false'
	end
'runopt'/1 =
    %% Line 879
    fun (_cor0) ->
	case _cor0 of
	  <'notempty'> when 'true' ->
	      %% Line 880
	      'true'
	  %% Line 881
	  <'notempty_atstart'> when 'true' ->
	      %% Line 882
	      'true'
	  %% Line 883
	  <'notbol'> when 'true' ->
	      %% Line 884
	      'true'
	  %% Line 885
	  <'noteol'> when 'true' ->
	      %% Line 886
	      'true'
	  %% Line 887
	  <{'offset',_cor2}> when 'true' ->
	      %% Line 888
	      'true'
	  %% Line 889
	  <{'capture',_cor3,_cor4}> when 'true' ->
	      %% Line 890
	      'true'
	  %% Line 891
	  <{'capture',_cor5}> when 'true' ->
	      %% Line 892
	      'true'
	  %% Line 893
	  <'global'> when 'true' ->
	      %% Line 894
	      'true'
	  %% Line 895
	  <{'match_limit',_cor6}> when 'true' ->
	      %% Line 896
	      'true'
	  %% Line 897
	  <{'match_limit_recursion',_cor7}> when 'true' ->
	      %% Line 898
	      'true'
	  %% Line 899
	  <_cor8> when 'true' ->
	      %% Line 900
	      'false'
	end
'to_binary'/2 =
    %% Line 902
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Bin,_X_IsUnicode>
	      when call 'erlang':'is_binary'
		    (Bin) ->
	      %% Line 903
	      Bin
	  %% Line 904
	  <Data,'true'> when 'true' ->
	      %% Line 905
	      call 'unicode':'characters_to_binary'
		  (Data, 'unicode')
	  %% Line 906
	  <Data,'false'> when 'true' ->
	      %% Line 907
	      call 'erlang':'iolist_to_binary'
		  (Data)
	  ( <_cor3,_cor2> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor3,_cor2})
		  -| [{'function_name',{'to_binary',2}}] )
	    -| ['compiler_generated'] )
	end
'module_info'/0 =
    fun () ->
	call 'erlang':'get_module_info'
	    ('re')
'module_info'/1 =
    fun (_cor0) ->
	call 'erlang':'get_module_info'
	    ('re', _cor0)
end
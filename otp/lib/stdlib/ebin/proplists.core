module 'proplists' ['append_values'/2,
		    'compact'/1,
		    'delete'/2,
		    'expand'/2,
		    'get_all_values'/2,
		    'get_bool'/2,
		    'get_keys'/1,
		    'get_value'/2,
		    'get_value'/3,
		    'is_defined'/2,
		    'lookup'/2,
		    'lookup_all'/2,
		    'module_info'/0,
		    'module_info'/1,
		    'normalize'/2,
		    'property'/1,
		    'property'/2,
		    'split'/2,
		    'substitute_aliases'/2,
		    'substitute_negations'/2,
		    'unfold'/1]
    attributes [%% Line 52
		'export_type' =
		    %% Line 52
		    [{'property',0}|[{'proplist',0}]],
		%% Line 54
		'type' =
		    %% Line 54
		    [{'property',{'type',54,'union',[{'type',54,'atom',[]}|[{'type',54,'tuple','any'}]]},[]}],
		%% Line 55
		'type' =
		    %% Line 55
		    [{'proplist',{'type',55,'list',[{'type',55,'property',[]}]},[]}],
		%% Line 66
		'spec' =
		    %% Line 66
		    [{{'property',1},[{'type',66,'bounded_fun',[{'type',66,'fun',[{'type',66,'product',[{'var',66,'PropertyIn'}]}|[{'var',66,'PropertyOut'}]]}|[[{'type',67,'constraint',[{'atom',67,'is_subtype'}|[[{'var',67,'PropertyIn'}|[{'type',67,'property',[]}]]]]}|[{'type',68,'constraint',[{'atom',68,'is_subtype'}|[[{'var',68,'PropertyOut'}|[{'type',68,'property',[]}]]]]}]]]]}]}],
		%% Line 83
		'spec' =
		    %% Line 83
		    [{{'property',2},[{'type',83,'bounded_fun',[{'type',83,'fun',[{'type',83,'product',[{'var',83,'Key'}|[{'var',83,'Value'}]]}|[{'var',83,'Property'}]]}|[[{'type',84,'constraint',[{'atom',84,'is_subtype'}|[[{'var',84,'Key'}|[{'type',84,'term',[]}]]]]}|[{'type',85,'constraint',[{'atom',85,'is_subtype'}|[[{'var',85,'Value'}|[{'type',85,'term',[]}]]]]}|[{'type',86,'constraint',[{'atom',86,'is_subtype'}|[[{'var',86,'Property'}|[{'type',86,'union',[{'type',86,'atom',[]}|[{'type',86,'tuple',[{'type',86,'term',[]}|[{'type',86,'term',[]}]]}]]}]]]]}]]]]]}]}],
		%% Line 101
		'spec' =
		    %% Line 101
		    [{{'unfold',1},[{'type',101,'bounded_fun',[{'type',101,'fun',[{'type',101,'product',[{'var',101,'ListIn'}]}|[{'var',101,'ListOut'}]]}|[[{'type',102,'constraint',[{'atom',102,'is_subtype'}|[[{'var',102,'ListIn'}|[{'type',102,'list',[{'type',102,'term',[]}]}]]]]}|[{'type',103,'constraint',[{'atom',103,'is_subtype'}|[[{'var',103,'ListOut'}|[{'type',103,'list',[{'type',103,'term',[]}]}]]]]}]]]]}]}],
		%% Line 120
		'spec' =
		    %% Line 120
		    [{{'compact',1},[{'type',120,'bounded_fun',[{'type',120,'fun',[{'type',120,'product',[{'var',120,'ListIn'}]}|[{'var',120,'ListOut'}]]}|[[{'type',121,'constraint',[{'atom',121,'is_subtype'}|[[{'var',121,'ListIn'}|[{'type',121,'list',[{'type',121,'property',[]}]}]]]]}|[{'type',122,'constraint',[{'atom',122,'is_subtype'}|[[{'var',122,'ListOut'}|[{'type',122,'list',[{'type',122,'property',[]}]}]]]]}]]]]}]}],
		%% Line 139
		'spec' =
		    %% Line 139
		    [{{'lookup',2},[{'type',139,'bounded_fun',[{'type',139,'fun',[{'type',139,'product',[{'var',139,'Key'}|[{'var',139,'List'}]]}|[{'type',139,'union',[{'atom',139,'none'}|[{'type',139,'tuple','any'}]]}]]}|[[{'type',140,'constraint',[{'atom',140,'is_subtype'}|[[{'var',140,'Key'}|[{'type',140,'term',[]}]]]]}|[{'type',141,'constraint',[{'atom',141,'is_subtype'}|[[{'var',141,'List'}|[{'type',141,'list',[{'type',141,'term',[]}]}]]]]}]]]]}]}],
		%% Line 161
		'spec' =
		    %% Line 161
		    [{{'lookup_all',2},[{'type',161,'bounded_fun',[{'type',161,'fun',[{'type',161,'product',[{'var',161,'Key'}|[{'var',161,'List'}]]}|[{'type',161,'list',[{'type',161,'tuple','any'}]}]]}|[[{'type',162,'constraint',[{'atom',162,'is_subtype'}|[[{'var',162,'Key'}|[{'type',162,'term',[]}]]]]}|[{'type',163,'constraint',[{'atom',163,'is_subtype'}|[[{'var',163,'List'}|[{'type',163,'list',[{'type',163,'term',[]}]}]]]]}]]]]}]}],
		%% Line 183
		'spec' =
		    %% Line 183
		    [{{'is_defined',2},[{'type',183,'bounded_fun',[{'type',183,'fun',[{'type',183,'product',[{'var',183,'Key'}|[{'var',183,'List'}]]}|[{'type',183,'boolean',[]}]]}|[[{'type',184,'constraint',[{'atom',184,'is_subtype'}|[[{'var',184,'Key'}|[{'type',184,'term',[]}]]]]}|[{'type',185,'constraint',[{'atom',185,'is_subtype'}|[[{'var',185,'List'}|[{'type',185,'list',[{'type',185,'term',[]}]}]]]]}]]]]}]}],
		%% Line 203
		'spec' =
		    %% Line 203
		    [{{'get_value',2},[{'type',203,'bounded_fun',[{'type',203,'fun',[{'type',203,'product',[{'var',203,'Key'}|[{'var',203,'List'}]]}|[{'type',203,'term',[]}]]}|[[{'type',204,'constraint',[{'atom',204,'is_subtype'}|[[{'var',204,'Key'}|[{'type',204,'term',[]}]]]]}|[{'type',205,'constraint',[{'atom',205,'is_subtype'}|[[{'var',205,'List'}|[{'type',205,'list',[{'type',205,'term',[]}]}]]]]}]]]]}]}],
		%% Line 220
		'spec' =
		    %% Line 220
		    [{{'get_value',3},[{'type',220,'bounded_fun',[{'type',220,'fun',[{'type',220,'product',[{'var',220,'Key'}|[{'var',220,'List'}|[{'var',220,'Default'}]]]}|[{'type',220,'term',[]}]]}|[[{'type',221,'constraint',[{'atom',221,'is_subtype'}|[[{'var',221,'Key'}|[{'type',221,'term',[]}]]]]}|[{'type',222,'constraint',[{'atom',222,'is_subtype'}|[[{'var',222,'List'}|[{'type',222,'list',[{'type',222,'term',[]}]}]]]]}|[{'type',223,'constraint',[{'atom',223,'is_subtype'}|[[{'var',223,'Default'}|[{'type',223,'term',[]}]]]]}]]]]]}]}],
		%% Line 249
		'spec' =
		    %% Line 249
		    [{{'get_all_values',2},[{'type',249,'bounded_fun',[{'type',249,'fun',[{'type',249,'product',[{'var',249,'Key'}|[{'var',249,'List'}]]}|[{'type',249,'list',[{'type',249,'term',[]}]}]]}|[[{'type',250,'constraint',[{'atom',250,'is_subtype'}|[[{'var',250,'Key'}|[{'type',250,'term',[]}]]]]}|[{'type',251,'constraint',[{'atom',251,'is_subtype'}|[[{'var',251,'List'}|[{'type',251,'list',[{'type',251,'term',[]}]}]]]]}]]]]}]}],
		%% Line 278
		'spec' =
		    %% Line 278
		    [{{'append_values',2},[{'type',278,'bounded_fun',[{'type',278,'fun',[{'type',278,'product',[{'var',278,'Key'}|[{'var',278,'ListIn'}]]}|[{'var',278,'ListOut'}]]}|[[{'type',279,'constraint',[{'atom',279,'is_subtype'}|[[{'var',279,'Key'}|[{'type',279,'term',[]}]]]]}|[{'type',280,'constraint',[{'atom',280,'is_subtype'}|[[{'var',280,'ListIn'}|[{'type',280,'list',[{'type',280,'term',[]}]}]]]]}|[{'type',281,'constraint',[{'atom',281,'is_subtype'}|[[{'var',281,'ListOut'}|[{'type',281,'list',[{'type',281,'term',[]}]}]]]]}]]]]]}]}],
		%% Line 312
		'spec' =
		    %% Line 312
		    [{{'get_bool',2},[{'type',312,'bounded_fun',[{'type',312,'fun',[{'type',312,'product',[{'var',312,'Key'}|[{'var',312,'List'}]]}|[{'type',312,'boolean',[]}]]}|[[{'type',313,'constraint',[{'atom',313,'is_subtype'}|[[{'var',313,'Key'}|[{'type',313,'term',[]}]]]]}|[{'type',314,'constraint',[{'atom',314,'is_subtype'}|[[{'var',314,'List'}|[{'type',314,'list',[{'type',314,'term',[]}]}]]]]}]]]]}]}],
		%% Line 339
		'spec' =
		    %% Line 339
		    [{{'get_keys',1},[{'type',339,'bounded_fun',[{'type',339,'fun',[{'type',339,'product',[{'var',339,'List'}]}|[{'type',339,'list',[{'type',339,'term',[]}]}]]}|[[{'type',340,'constraint',[{'atom',340,'is_subtype'}|[[{'var',340,'List'}|[{'type',340,'list',[{'type',340,'term',[]}]}]]]]}]]]}]}],
		%% Line 362
		'spec' =
		    %% Line 362
		    [{{'delete',2},[{'type',362,'bounded_fun',[{'type',362,'fun',[{'type',362,'product',[{'var',362,'Key'}|[{'var',362,'List'}]]}|[{'var',362,'List'}]]}|[[{'type',363,'constraint',[{'atom',363,'is_subtype'}|[[{'var',363,'Key'}|[{'type',363,'term',[]}]]]]}|[{'type',364,'constraint',[{'atom',364,'is_subtype'}|[[{'var',364,'List'}|[{'type',364,'list',[{'type',364,'term',[]}]}]]]]}]]]]}]}],
		%% Line 395
		'spec' =
		    %% Line 395
		    [{{'substitute_aliases',2},[{'type',395,'bounded_fun',[{'type',395,'fun',[{'type',395,'product',[{'var',395,'Aliases'}|[{'var',395,'ListIn'}]]}|[{'var',395,'ListOut'}]]}|[[{'type',396,'constraint',[{'atom',396,'is_subtype'}|[[{'var',396,'Aliases'}|[{'type',396,'list',[{'type',396,'tuple',[{'var',396,'Key'}|[{'var',396,'Key'}]]}]}]]]]}|[{'type',397,'constraint',[{'atom',397,'is_subtype'}|[[{'var',397,'Key'}|[{'type',397,'term',[]}]]]]}|[{'type',398,'constraint',[{'atom',398,'is_subtype'}|[[{'var',398,'ListIn'}|[{'type',398,'list',[{'type',398,'term',[]}]}]]]]}|[{'type',399,'constraint',[{'atom',399,'is_subtype'}|[[{'var',399,'ListOut'}|[{'type',399,'list',[{'type',399,'term',[]}]}]]]]}]]]]]]}]}],
		%% Line 439
		'spec' =
		    %% Line 439
		    [{{'substitute_negations',2},[{'type',439,'bounded_fun',[{'type',439,'fun',[{'type',439,'product',[{'var',439,'Negations'}|[{'var',439,'ListIn'}]]}|[{'var',439,'ListOut'}]]}|[[{'type',440,'constraint',[{'atom',440,'is_subtype'}|[[{'var',440,'Negations'}|[{'type',440,'list',[{'type',440,'tuple',[{'var',440,'Key'}|[{'var',440,'Key'}]]}]}]]]]}|[{'type',441,'constraint',[{'atom',441,'is_subtype'}|[[{'var',441,'Key'}|[{'type',441,'term',[]}]]]]}|[{'type',442,'constraint',[{'atom',442,'is_subtype'}|[[{'var',442,'ListIn'}|[{'type',442,'list',[{'type',442,'term',[]}]}]]]]}|[{'type',443,'constraint',[{'atom',443,'is_subtype'}|[[{'var',443,'ListOut'}|[{'type',443,'list',[{'type',443,'term',[]}]}]]]]}]]]]]]}]}],
		%% Line 506
		'spec' =
		    %% Line 506
		    [{{'expand',2},[{'type',506,'bounded_fun',[{'type',506,'fun',[{'type',506,'product',[{'var',506,'Expansions'}|[{'var',506,'ListIn'}]]}|[{'var',506,'ListOut'}]]}|[[{'type',507,'constraint',[{'atom',507,'is_subtype'}|[[{'var',507,'Expansions'}|[{'type',507,'list',[{'type',507,'tuple',[{'ann_type',507,[{'var',507,'Property'}|[{'type',507,'property',[]}]]}|[{'ann_type',507,[{'var',507,'Expansion'}|[{'type',507,'list',[{'type',507,'term',[]}]}]]}]]}]}]]]]}|[{'type',508,'constraint',[{'atom',508,'is_subtype'}|[[{'var',508,'ListIn'}|[{'type',508,'list',[{'type',508,'term',[]}]}]]]]}|[{'type',509,'constraint',[{'atom',509,'is_subtype'}|[[{'var',509,'ListOut'}|[{'type',509,'list',[{'type',509,'term',[]}]}]]]]}]]]]]}]}],
		%% Line 609
		'spec' =
		    %% Line 609
		    [{{'normalize',2},[{'type',609,'bounded_fun',[{'type',609,'fun',[{'type',609,'product',[{'var',609,'ListIn'}|[{'var',609,'Stages'}]]}|[{'var',609,'ListOut'}]]}|[[{'type',610,'constraint',[{'atom',610,'is_subtype'}|[[{'var',610,'ListIn'}|[{'type',610,'list',[{'type',610,'term',[]}]}]]]]}|[{'type',611,'constraint',[{'atom',611,'is_subtype'}|[[{'var',611,'Stages'}|[{'type',611,'list',[{'var',611,'Operation'}]}]]]]}|[{'type',612,'constraint',[{'atom',612,'is_subtype'}|[[{'var',612,'Operation'}|[{'type',612,'union',[{'type',612,'tuple',[{'atom',612,'aliases'}|[{'var',612,'Aliases'}]]}|[{'type',613,'tuple',[{'atom',613,'negations'}|[{'var',613,'Negations'}]]}|[{'type',614,'tuple',[{'atom',614,'expand'}|[{'var',614,'Expansions'}]]}]]]}]]]]}|[{'type',615,'constraint',[{'atom',615,'is_subtype'}|[[{'var',615,'Aliases'}|[{'type',615,'list',[{'type',615,'tuple',[{'var',615,'Key'}|[{'var',615,'Key'}]]}]}]]]]}|[{'type',616,'constraint',[{'atom',616,'is_subtype'}|[[{'var',616,'Negations'}|[{'type',616,'list',[{'type',616,'tuple',[{'var',616,'Key'}|[{'var',616,'Key'}]]}]}]]]]}|[{'type',617,'constraint',[{'atom',617,'is_subtype'}|[[{'var',617,'Expansions'}|[{'type',617,'list',[{'type',617,'tuple',[{'ann_type',617,[{'var',617,'Property'}|[{'type',617,'property',[]}]]}|[{'ann_type',617,[{'var',617,'Expansion'}|[{'type',617,'list',[{'type',617,'term',[]}]}]]}]]}]}]]]]}|[{'type',618,'constraint',[{'atom',618,'is_subtype'}|[[{'var',618,'ListOut'}|[{'type',618,'list',[{'type',618,'term',[]}]}]]]]}]]]]]]]]]}]}],
		%% Line 645
		'spec' =
		    %% Line 645
		    [{{'split',2},[{'type',645,'bounded_fun',[{'type',645,'fun',[{'type',645,'product',[{'var',645,'List'}|[{'var',645,'Keys'}]]}|[{'type',645,'tuple',[{'var',645,'Lists'}|[{'var',645,'Rest'}]]}]]}|[[{'type',646,'constraint',[{'atom',646,'is_subtype'}|[[{'var',646,'List'}|[{'type',646,'list',[{'type',646,'term',[]}]}]]]]}|[{'type',647,'constraint',[{'atom',647,'is_subtype'}|[[{'var',647,'Keys'}|[{'type',647,'list',[{'type',647,'term',[]}]}]]]]}|[{'type',648,'constraint',[{'atom',648,'is_subtype'}|[[{'var',648,'Lists'}|[{'type',648,'list',[{'type',648,'list',[{'type',648,'term',[]}]}]}]]]]}|[{'type',649,'constraint',[{'atom',649,'is_subtype'}|[[{'var',649,'Rest'}|[{'type',649,'list',[{'type',649,'term',[]}]}]]]]}]]]]]]}]}]]
'property'/1 =
    %% Line 70
    fun (_cor0) ->
	case _cor0 of
	  <{Key,'true'}>
	      when call 'erlang':'is_atom'
		    (Key) ->
	      %% Line 71
	      Key
	  %% Line 72
	  <Property> when 'true' ->
	      %% Line 73
	      Property
	end
'property'/2 =
    %% Line 88
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Key,'true'>
	      when call 'erlang':'is_atom'
		    (Key) ->
	      %% Line 89
	      Key
	  %% Line 90
	  <Key,Value> when 'true' ->
	      %% Line 91
	      {Key,Value}
	end
'unfold'/1 =
    %% Line 105
    fun (_cor0) ->
	case _cor0 of
	  <[P|Ps]> when 'true' ->
	      %% Line 106
	      case <> of
		<>
		    when call 'erlang':'is_atom'
			  (P) ->
		    let <_cor1> =
			%% Line 107
			apply 'unfold'/1
			    (Ps)
		    in  %% Line 107
			[{P,'true'}|_cor1]
		%% Line 108
		<> when 'true' ->
		    let <_cor2> =
			%% Line 109
			apply 'unfold'/1
			    (Ps)
		    in  %% Line 109
			[P|_cor2]
	      end
	  %% Line 111
	  <[]> when 'true' ->
	      %% Line 112
	      []
	  ( <_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor3})
		  -| [{'function_name',{'unfold',1}}] )
	    -| ['compiler_generated'] )
	end
'compact'/1 =
    %% Line 124
    fun (_cor0) ->
	%% Line 125
	( letrec
	      'lc$^0'/1 =
		  fun (_cor3) ->
		      case _cor3 of
			<[P|_cor2]> when 'true' ->
			    let <_cor4> =
				apply 'property'/1
				    (P)
			    in  let <_cor5> =
				    apply 'lc$^0'/1
					(_cor2)
				in  ( [_cor4|_cor5]
				      -| ['compiler_generated'] )
			<[]> when 'true' ->
			    []
			( <_cor3> when 'true' ->
			      ( primop 'match_fail'
				    ({'function_clause',_cor3})
				-| [{'function_name',{'lc$^0',1}}] )
			  -| ['compiler_generated'] )
		      end
	  in  apply 'lc$^0'/1
		  (_cor0)
	  -| ['list_comprehension'] )
'lookup'/2 =
    %% Line 143
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Key,[P|Ps]> when 'true' ->
	      %% Line 144
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    %% Line 145
		    {Key,'true'}
		%% Line 146
		<>
		    when try
			  let <_cor4> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor5> =
				  call 'erlang':'>='
				      (_cor4, 1)
			      in  let <_cor6> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor7> =
					  call 'erlang':'=:='
					      (_cor6, Key)
				      in  call 'erlang':'and'
					      (_cor5, _cor7)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    %% Line 148
		    P
		%% Line 149
		<> when 'true' ->
		    %% Line 150
		    apply 'lookup'/2
			(Key, Ps)
	      end
	  %% Line 152
	  <_X_Key,[]> when 'true' ->
	      %% Line 153
	      'none'
	  ( <_cor9,_cor8> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor9,_cor8})
		  -| [{'function_name',{'lookup',2}}] )
	    -| ['compiler_generated'] )
	end
'lookup_all'/2 =
    %% Line 165
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Key,[P|Ps]> when 'true' ->
	      %% Line 166
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    let <_cor4> =
			%% Line 167
			apply 'lookup_all'/2
			    (Key, Ps)
		    in  %% Line 167
			[{Key,'true'}|_cor4]
		%% Line 168
		<>
		    when try
			  let <_cor5> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor6> =
				  call 'erlang':'>='
				      (_cor5, 1)
			      in  let <_cor7> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor8> =
					  call 'erlang':'=:='
					      (_cor7, Key)
				      in  call 'erlang':'and'
					      (_cor6, _cor8)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    let <_cor9> =
			%% Line 169
			apply 'lookup_all'/2
			    (Key, Ps)
		    in  %% Line 169
			[P|_cor9]
		%% Line 170
		<> when 'true' ->
		    %% Line 171
		    apply 'lookup_all'/2
			(Key, Ps)
	      end
	  %% Line 173
	  <_X_Key,[]> when 'true' ->
	      %% Line 174
	      []
	  ( <_cor11,_cor10> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor11,_cor10})
		  -| [{'function_name',{'lookup_all',2}}] )
	    -| ['compiler_generated'] )
	end
'is_defined'/2 =
    %% Line 187
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Key,[P|Ps]> when 'true' ->
	      %% Line 188
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    %% Line 189
		    'true'
		%% Line 190
		<>
		    when try
			  let <_cor4> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor5> =
				  call 'erlang':'>='
				      (_cor4, 1)
			      in  let <_cor6> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor7> =
					  call 'erlang':'=:='
					      (_cor6, Key)
				      in  call 'erlang':'and'
					      (_cor5, _cor7)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    %% Line 191
		    'true'
		%% Line 192
		<> when 'true' ->
		    %% Line 193
		    apply 'is_defined'/2
			(Key, Ps)
	      end
	  %% Line 195
	  <_X_Key,[]> when 'true' ->
	      %% Line 196
	      'false'
	  ( <_cor9,_cor8> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor9,_cor8})
		  -| [{'function_name',{'is_defined',2}}] )
	    -| ['compiler_generated'] )
	end
'get_value'/2 =
    %% Line 207
    fun (_cor1,_cor0) ->
	%% Line 208
	apply 'get_value'/3
	    (_cor1, _cor0, 'undefined')
'get_value'/3 =
    %% Line 225
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <Key,[P|Ps],Default> when 'true' ->
	      %% Line 226
	      case <> of
		<>
		    when let <_cor3> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor4> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor3, _cor4) ->
		    %% Line 227
		    'true'
		%% Line 228
		<>
		    when try
			  let <_cor5> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor6> =
				  call 'erlang':'>='
				      (_cor5, 1)
			      in  let <_cor7> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor8> =
					  call 'erlang':'=:='
					      (_cor7, Key)
				      in  call 'erlang':'and'
					      (_cor6, _cor8)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    %% Line 229
		    case P of
		      %% Line 230
		      <{_cor13,Value}> when 'true' ->
			  %% Line 231
			  Value
		      %% Line 232
		      <_cor14> when 'true' ->
			  %% Line 234
			  Default
		    end
		%% Line 236
		<> when 'true' ->
		    %% Line 237
		    apply 'get_value'/3
			(Key, Ps, Default)
	      end
	  %% Line 239
	  <_X_Key,[],Default> when 'true' ->
	      %% Line 240
	      Default
	  ( <_cor12,_cor11,_cor10> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor12,_cor11,_cor10})
		  -| [{'function_name',{'get_value',3}}] )
	    -| ['compiler_generated'] )
	end
'get_all_values'/2 =
    %% Line 253
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Key,[P|Ps]> when 'true' ->
	      %% Line 254
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    let <_cor4> =
			%% Line 255
			apply 'get_all_values'/2
			    (Key, Ps)
		    in  %% Line 255
			['true'|_cor4]
		%% Line 256
		<>
		    when try
			  let <_cor5> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor6> =
				  call 'erlang':'>='
				      (_cor5, 1)
			      in  let <_cor7> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor8> =
					  call 'erlang':'=:='
					      (_cor7, Key)
				      in  call 'erlang':'and'
					      (_cor6, _cor8)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    %% Line 257
		    case P of
		      %% Line 258
		      <{_cor13,Value}> when 'true' ->
			  let <_cor9> =
			      %% Line 259
			      apply 'get_all_values'/2
				  (Key, Ps)
			  in  %% Line 259
			      [Value|_cor9]
		      %% Line 260
		      <_cor14> when 'true' ->
			  %% Line 261
			  apply 'get_all_values'/2
			      (Key, Ps)
		    end
		%% Line 263
		<> when 'true' ->
		    %% Line 264
		    apply 'get_all_values'/2
			(Key, Ps)
	      end
	  %% Line 266
	  <_X_Key,[]> when 'true' ->
	      %% Line 267
	      []
	  ( <_cor12,_cor11> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor12,_cor11})
		  -| [{'function_name',{'get_all_values',2}}] )
	    -| ['compiler_generated'] )
	end
'append_values'/2 =
    %% Line 283
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Key,[P|Ps]> when 'true' ->
	      %% Line 284
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    let <_cor4> =
			%% Line 285
			apply 'append_values'/2
			    (Key, Ps)
		    in  %% Line 285
			['true'|_cor4]
		%% Line 286
		<>
		    when try
			  let <_cor5> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor6> =
				  call 'erlang':'>='
				      (_cor5, 1)
			      in  let <_cor7> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor8> =
					  call 'erlang':'=:='
					      (_cor7, Key)
				      in  call 'erlang':'and'
					      (_cor6, _cor8)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    %% Line 287
		    case P of
		      %% Line 288
		      <{_cor14,Value}>
			  when call 'erlang':'is_list'
				(Value) ->
			  let <_cor9> =
			      %% Line 289
			      apply 'append_values'/2
				  (Key, Ps)
			  in  %% Line 289
			      call 'erlang':'++'
				  (Value, _cor9)
		      %% Line 290
		      <{_cor15,Value}> when 'true' ->
			  let <_cor10> =
			      %% Line 291
			      apply 'append_values'/2
				  (Key, Ps)
			  in  %% Line 291
			      [Value|_cor10]
		      %% Line 292
		      <_cor16> when 'true' ->
			  %% Line 293
			  apply 'append_values'/2
			      (Key, Ps)
		    end
		%% Line 295
		<> when 'true' ->
		    %% Line 296
		    apply 'append_values'/2
			(Key, Ps)
	      end
	  %% Line 298
	  <_X_Key,[]> when 'true' ->
	      %% Line 299
	      []
	  ( <_cor13,_cor12> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor13,_cor12})
		  -| [{'function_name',{'append_values',2}}] )
	    -| ['compiler_generated'] )
	end
'get_bool'/2 =
    %% Line 316
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Key,[P|Ps]> when 'true' ->
	      %% Line 317
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    %% Line 318
		    'true'
		%% Line 319
		<>
		    when try
			  let <_cor4> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor5> =
				  call 'erlang':'>='
				      (_cor4, 1)
			      in  let <_cor6> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor7> =
					  call 'erlang':'=:='
					      (_cor6, Key)
				      in  call 'erlang':'and'
					      (_cor5, _cor7)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    %% Line 320
		    case P of
		      %% Line 321
		      <{_cor11,'true'}> when 'true' ->
			  %% Line 322
			  'true'
		      %% Line 323
		      <_cor12> when 'true' ->
			  %% Line 325
			  'false'
		    end
		%% Line 327
		<> when 'true' ->
		    %% Line 328
		    apply 'get_bool'/2
			(Key, Ps)
	      end
	  %% Line 330
	  <_X_Key,[]> when 'true' ->
	      %% Line 331
	      'false'
	  ( <_cor10,_cor9> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor10,_cor9})
		  -| [{'function_name',{'get_bool',2}}] )
	    -| ['compiler_generated'] )
	end
'get_keys'/1 =
    %% Line 342
    fun (_cor0) ->
	let <_cor1> =
	    %% Line 343
	    call 'sets':'new'
		()
	in  let <_cor2> =
		%% Line 343
		apply 'get_keys'/2
		    (_cor0, _cor1)
	    in  %% Line 343
		call 'sets':'to_list'
		    (_cor2)
'get_keys'/2 =
    %% Line 345
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[P|Ps],Keys> when 'true' ->
	      %% Line 346
	      case <> of
		<>
		    when call 'erlang':'is_atom'
			  (P) ->
		    let <_cor2> =
			%% Line 347
			call 'sets':'add_element'
			    (P, Keys)
		    in  %% Line 347
			apply 'get_keys'/2
			    (Ps, _cor2)
		%% Line 348
		<>
		    when try
			  let <_cor3> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  call 'erlang':'>='
				  (_cor3, 1)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    let <_cor4> =
			%% Line 349
			call 'erlang':'element'
			    (1, P)
		    in  let <_cor5> =
			    %% Line 349
			    call 'sets':'add_element'
				(_cor4, Keys)
			in  %% Line 349
			    apply 'get_keys'/2
				(Ps, _cor5)
		%% Line 350
		<> when 'true' ->
		    %% Line 351
		    apply 'get_keys'/2
			(Ps, Keys)
	      end
	  %% Line 353
	  <[],Keys> when 'true' ->
	      %% Line 354
	      Keys
	  ( <_cor7,_cor6> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor7,_cor6})
		  -| [{'function_name',{'get_keys',2}}] )
	    -| ['compiler_generated'] )
	end
'delete'/2 =
    %% Line 366
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Key,[P|Ps]> when 'true' ->
	      %% Line 367
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    %% Line 368
		    apply 'delete'/2
			(Key, Ps)
		%% Line 369
		<>
		    when try
			  let <_cor4> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor5> =
				  call 'erlang':'>='
				      (_cor4, 1)
			      in  let <_cor6> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor7> =
					  call 'erlang':'=:='
					      (_cor6, Key)
				      in  call 'erlang':'and'
					      (_cor5, _cor7)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    %% Line 370
		    apply 'delete'/2
			(Key, Ps)
		%% Line 371
		<> when 'true' ->
		    let <_cor8> =
			%% Line 372
			apply 'delete'/2
			    (Key, Ps)
		    in  %% Line 372
			[P|_cor8]
	      end
	  %% Line 374
	  <_cor11,[]> when 'true' ->
	      %% Line 375
	      []
	  ( <_cor10,_cor9> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor10,_cor9})
		  -| [{'function_name',{'delete',2}}] )
	    -| ['compiler_generated'] )
	end
'substitute_aliases'/2 =
    %% Line 401
    fun (_cor1,_cor0) ->
	%% Line 402
	( letrec
	      'lc$^0'/1 =
		  fun (_cor4) ->
		      case _cor4 of
			<[P|_cor3]> when 'true' ->
			    let <_cor5> =
				apply 'substitute_aliases_1'/2
				    (_cor1, P)
			    in  let <_cor6> =
				    apply 'lc$^0'/1
					(_cor3)
				in  ( [_cor5|_cor6]
				      -| ['compiler_generated'] )
			<[]> when 'true' ->
			    []
			( <_cor4> when 'true' ->
			      ( primop 'match_fail'
				    ({'function_clause',_cor4})
				-| [{'function_name',{'lc$^0',1}}] )
			  -| ['compiler_generated'] )
		      end
	  in  apply 'lc$^0'/1
		  (_cor0)
	  -| ['list_comprehension'] )
'substitute_aliases_1'/2 =
    %% Line 404
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[{Key,Key1}|As],P> when 'true' ->
	      %% Line 405
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    %% Line 406
		    apply 'property'/2
			(Key1, 'true')
		%% Line 407
		<>
		    when try
			  let <_cor4> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor5> =
				  call 'erlang':'>='
				      (_cor4, 1)
			      in  let <_cor6> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor7> =
					  call 'erlang':'=:='
					      (_cor6, Key)
				      in  call 'erlang':'and'
					      (_cor5, _cor7)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    let <_cor8> =
			%% Line 408
			call 'erlang':'setelement'
			    (1, P, Key1)
		    in  %% Line 408
			apply 'property'/1
			    (_cor8)
		%% Line 409
		<> when 'true' ->
		    %% Line 410
		    apply 'substitute_aliases_1'/2
			(As, P)
	      end
	  %% Line 412
	  <[],P> when 'true' ->
	      %% Line 413
	      P
	  ( <_cor10,_cor9> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor10,_cor9})
		  -| [{'function_name',{'substitute_aliases_1',2}}] )
	    -| ['compiler_generated'] )
	end
'substitute_negations'/2 =
    %% Line 445
    fun (_cor1,_cor0) ->
	%% Line 446
	( letrec
	      'lc$^0'/1 =
		  fun (_cor4) ->
		      case _cor4 of
			<[P|_cor3]> when 'true' ->
			    let <_cor5> =
				apply 'substitute_negations_1'/2
				    (_cor1, P)
			    in  let <_cor6> =
				    apply 'lc$^0'/1
					(_cor3)
				in  ( [_cor5|_cor6]
				      -| ['compiler_generated'] )
			<[]> when 'true' ->
			    []
			( <_cor4> when 'true' ->
			      ( primop 'match_fail'
				    ({'function_clause',_cor4})
				-| [{'function_name',{'lc$^0',1}}] )
			  -| ['compiler_generated'] )
		      end
	  in  apply 'lc$^0'/1
		  (_cor0)
	  -| ['list_comprehension'] )
'substitute_negations_1'/2 =
    %% Line 448
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[{Key,Key1}|As],P> when 'true' ->
	      %% Line 449
	      case <> of
		<>
		    when let <_cor2> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor3> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor2, _cor3) ->
		    %% Line 450
		    apply 'property'/2
			(Key1, 'false')
		%% Line 451
		<>
		    when try
			  let <_cor4> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor5> =
				  call 'erlang':'>='
				      (_cor4, 1)
			      in  let <_cor6> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor7> =
					  call 'erlang':'=:='
					      (_cor6, Key)
				      in  call 'erlang':'and'
					      (_cor5, _cor7)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    %% Line 452
		    case P of
		      %% Line 453
		      <{_cor11,'true'}> when 'true' ->
			  %% Line 454
			  apply 'property'/2
			      (Key1, 'false')
		      %% Line 455
		      <{_cor12,'false'}> when 'true' ->
			  %% Line 456
			  apply 'property'/2
			      (Key1, 'true')
		      %% Line 457
		      <_cor13> when 'true' ->
			  %% Line 461
			  apply 'property'/2
			      (Key1, 'true')
		    end
		%% Line 463
		<> when 'true' ->
		    %% Line 464
		    apply 'substitute_negations_1'/2
			(As, P)
	      end
	  %% Line 466
	  <[],P> when 'true' ->
	      %% Line 467
	      P
	  ( <_cor10,_cor9> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor10,_cor9})
		  -| [{'function_name',{'substitute_negations_1',2}}] )
	    -| ['compiler_generated'] )
	end
'expand'/2 =
    %% Line 511
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <Es,Ps>
	      when call 'erlang':'is_list'
		    (Ps) ->
	      let <_cor7> =
		  %% Line 512
		  ( letrec
			'lc$^0'/1 =
			    fun (_cor4) ->
				case _cor4 of
				  <[{P,V}|_cor3]> when 'true' ->
				      let <_cor5> =
					  apply 'property'/1
					      (P)
				      in  let <_cor6> =
					      apply 'lc$^0'/1
						  (_cor3)
					  in  ( [{_cor5,V}|_cor6]
						-| ['compiler_generated'] )
				  ( <[_cor2|_cor3]> when 'true' ->
					apply 'lc$^0'/1
					    (_cor3)
				    -| ['compiler_generated'] )
				  <[]> when 'true' ->
				      []
				  ( <_cor4> when 'true' ->
					( primop 'match_fail'
					      ({'function_clause',_cor4})
					  -| [{'function_name',{'lc$^0',1}}] )
				    -| ['compiler_generated'] )
				end
		    in  apply 'lc$^0'/1
			    (Es)
		    -| ['list_comprehension'] )
	      in  let <_cor9> =
		      %% Line 513
		      apply 'key_uniq'/1
			  (_cor7)
		  in  let <_cor10> =
			  %% Line 513
			  apply 'expand_0'/2
			      (_cor9, Ps)
		      in  %% Line 513
			  apply 'flatten'/1
			      (_cor10)
	  ( <_cor12,_cor11> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor12,_cor11})
		  -| [{'function_name',{'expand',2}}] )
	    -| ['compiler_generated'] )
	end
'expand_0'/2 =
    %% Line 520
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <[{P,L}|Es],Ps> when 'true' ->
	      let <_cor2> =
		  %% Line 521
		  apply 'expand_1'/3
		      (P, L, Ps)
	      in  %% Line 521
		  apply 'expand_0'/2
		      (Es, _cor2)
	  %% Line 522
	  <[],Ps> when 'true' ->
	      %% Line 523
	      Ps
	  ( <_cor4,_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor4,_cor3})
		  -| [{'function_name',{'expand_0',2}}] )
	    -| ['compiler_generated'] )
	end
'expand_1'/3 =
    %% Line 525
    fun (_cor2,_cor1,_cor0) ->
	%% Line 528
	case <> of
	  <>
	      when call 'erlang':'is_atom'
		    (_cor2) ->
	      %% Line 529
	      apply 'expand_2'/4
		  (_cor2, _cor2, _cor1, _cor0)
	  %% Line 530
	  <>
	      when try
		    let <_cor3> =
			call 'erlang':'tuple_size'
			    (_cor2)
		    in  call 'erlang':'>='
			    (_cor3, 1)
		of <Try> ->
		    Try
		catch <T,R> ->
		    'false' ->
	      let <_cor4> =
		  %% Line 531
		  call 'erlang':'element'
		      (1, _cor2)
	      in  %% Line 531
		  apply 'expand_2'/4
		      (_cor4, _cor2, _cor1, _cor0)
	  %% Line 532
	  <> when 'true' ->
	      _cor0
	end
'expand_2'/4 =
    %% Line 536
    fun (_cor3,_cor2,_cor1,_cor0) ->
	case <_cor3,_cor2,_cor1,_cor0> of
	  <Key,P1,L,[P|Ps]> when 'true' ->
	      %% Line 537
	      case <> of
		<>
		    when let <_cor4> =
			  call 'erlang':'is_atom'
			      (P)
		      in  let <_cor5> =
			      call 'erlang':'=:='
				  (P, Key)
			  in  call 'erlang':'and'
				  (_cor4, _cor5) ->
		    %% Line 538
		    apply 'expand_3'/5
			(Key, P1, P, L, Ps)
		%% Line 539
		<>
		    when try
			  let <_cor6> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  let <_cor7> =
				  call 'erlang':'>='
				      (_cor6, 1)
			      in  let <_cor8> =
				      call 'erlang':'element'
					  (1, P)
				  in  let <_cor9> =
					  call 'erlang':'=:='
					      (_cor8, Key)
				      in  call 'erlang':'and'
					      (_cor7, _cor9)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    let <_cor10> =
			%% Line 540
			apply 'property'/1
			    (P)
		    in  %% Line 540
			apply 'expand_3'/5
			    (Key, P1, _cor10, L, Ps)
		%% Line 541
		<> when 'true' ->
		    let <_cor11> =
			%% Line 545
			apply 'expand_2'/4
			    (Key, P1, L, Ps)
		    in  %% Line 545
			[P|_cor11]
	      end
	  %% Line 547
	  <_cor16,_cor17,_cor18,[]> when 'true' ->
	      %% Line 548
	      []
	  ( <_cor15,_cor14,_cor13,_cor12> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor15,_cor14,_cor13,_cor12})
		  -| [{'function_name',{'expand_2',4}}] )
	    -| ['compiler_generated'] )
	end
'expand_3'/5 =
    %% Line 550
    fun (_cor4,_cor3,_cor2,_cor1,_cor0) ->
	%% Line 555
	case <> of
	  <>
	      when call 'erlang':'=:='
		    (_cor3,
		     _cor2) ->
	      let <_cor5> =
		  %% Line 556
		  apply 'delete'/2
		      (_cor4, _cor0)
	      in  %% Line 556
		  [_cor1|_cor5]
	  %% Line 557
	  <> when 'true' ->
	      %% Line 559
	      [_cor2|_cor0]
	end
'key_uniq'/1 =
    %% Line 562
    fun (_cor0) ->
	case _cor0 of
	  <[{K,V}|Ps]> when 'true' ->
	      let <_cor1> =
		  %% Line 563
		  apply 'key_uniq_1'/2
		      (K, Ps)
	      in  %% Line 563
		  [{K,V}|_cor1]
	  %% Line 564
	  <[]> when 'true' ->
	      %% Line 565
	      []
	  ( <_cor2> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor2})
		  -| [{'function_name',{'key_uniq',1}}] )
	    -| ['compiler_generated'] )
	end
'key_uniq_1'/2 =
    %% Line 567
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <K,[{K1,V}|Ps]> when 'true' ->
	      %% Line 568
	      case <> of
		<>
		    when call 'erlang':'=:='
			  (K,
			   K1) ->
		    %% Line 569
		    apply 'key_uniq_1'/2
			(K, Ps)
		%% Line 570
		<> when 'true' ->
		    let <_cor2> =
			%% Line 571
			apply 'key_uniq_1'/2
			    (K1, Ps)
		    in  %% Line 571
			[{K1,V}|_cor2]
	      end
	  %% Line 573
	  <_cor5,[]> when 'true' ->
	      %% Line 574
	      []
	  ( <_cor4,_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor4,_cor3})
		  -| [{'function_name',{'key_uniq_1',2}}] )
	    -| ['compiler_generated'] )
	end
'flatten'/1 =
    %% Line 578
    fun (_cor0) ->
	case _cor0 of
	  <[E|Es]>
	      when call 'erlang':'is_list'
		    (E) ->
	      let <_cor1> =
		  %% Line 579
		  apply 'flatten'/1
		      (Es)
	      in  %% Line 579
		  call 'erlang':'++'
		      (E, _cor1)
	  %% Line 580
	  <[E|Es]> when 'true' ->
	      let <_cor2> =
		  %% Line 581
		  apply 'flatten'/1
		      (Es)
	      in  %% Line 581
		  [E|_cor2]
	  %% Line 582
	  <[]> when 'true' ->
	      %% Line 583
	      []
	  ( <_cor3> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor3})
		  -| [{'function_name',{'flatten',1}}] )
	    -| ['compiler_generated'] )
	end
'normalize'/2 =
    %% Line 620
    fun (_cor1,_cor0) ->
	case <_cor1,_cor0> of
	  <L,[{'aliases',As}|Xs]> when 'true' ->
	      let <_cor2> =
		  %% Line 621
		  apply 'substitute_aliases'/2
		      (As, L)
	      in  %% Line 621
		  apply 'normalize'/2
		      (_cor2, Xs)
	  %% Line 622
	  <L,[{'expand',Es}|Xs]> when 'true' ->
	      let <_cor3> =
		  %% Line 623
		  apply 'expand'/2
		      (Es, L)
	      in  %% Line 623
		  apply 'normalize'/2
		      (_cor3, Xs)
	  %% Line 624
	  <L,[{'negations',Ns}|Xs]> when 'true' ->
	      let <_cor4> =
		  %% Line 625
		  apply 'substitute_negations'/2
		      (Ns, L)
	      in  %% Line 625
		  apply 'normalize'/2
		      (_cor4, Xs)
	  %% Line 626
	  <L,[]> when 'true' ->
	      %% Line 627
	      apply 'compact'/1
		  (L)
	  ( <_cor6,_cor5> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor6,_cor5})
		  -| [{'function_name',{'normalize',2}}] )
	    -| ['compiler_generated'] )
	end
'split'/2 =
    %% Line 651
    fun (_cor1,_cor0) ->
	let <_cor6> =
	    %% Line 652
	    ( letrec
		  'lc$^0'/1 =
		      fun (_cor4) ->
			  case _cor4 of
			    <[K|_cor3]> when 'true' ->
				let <_cor5> =
				    apply 'lc$^0'/1
					(_cor3)
				in  ( [{K,[]}|_cor5]
				      -| ['compiler_generated'] )
			    <[]> when 'true' ->
				[]
			    ( <_cor4> when 'true' ->
				  ( primop 'match_fail'
					({'function_clause',_cor4})
				    -| [{'function_name',{'lc$^0',1}}] )
			      -| ['compiler_generated'] )
			  end
	      in  apply 'lc$^0'/1
		      (_cor0)
	      -| ['list_comprehension'] )
	in  let <_cor7> =
		%% Line 652
		call 'dict':'from_list'
		    (_cor6)
	    in  %% Line 652
		case apply 'split'/3
			 (_cor1, _cor7, []) of
		  <{Store,Rest}> when 'true' ->
		      let <_cor16> =
			  %% Line 653
			  ( letrec
				'lc$^1'/1 =
				    fun (_cor12) ->
					case _cor12 of
					  <[K|_cor11]> when 'true' ->
					      let <_cor13> =
						  call 'dict':'fetch'
						      (K, Store)
					      in  let <_cor14> =
						      call 'lists':'reverse'
							  (_cor13)
						  in  let <_cor15> =
							  apply 'lc$^1'/1
							      (_cor11)
						      in  ( [_cor14|_cor15]
							    -| ['compiler_generated'] )
					  <[]> when 'true' ->
					      []
					  ( <_cor12> when 'true' ->
						( primop 'match_fail'
						      ({'function_clause',_cor12})
						  -| [{'function_name',{'lc$^1',1}}] )
					    -| ['compiler_generated'] )
					end
			    in  apply 'lc$^1'/1
				    (_cor0)
			    -| ['list_comprehension'] )
		      in  let <_cor9> =
			      %% Line 654
			      call 'lists':'reverse'
				  (Rest)
			  in  %% Line 653
			      {_cor16,_cor9}
		  ( <_cor8> when 'true' ->
			primop 'match_fail'
			    ({'badmatch',_cor8})
		    -| ['compiler_generated'] )
		end
'split'/3 =
    %% Line 656
    fun (_cor2,_cor1,_cor0) ->
	case <_cor2,_cor1,_cor0> of
	  <[P|Ps],Store,Rest> when 'true' ->
	      %% Line 657
	      case <> of
		<>
		    when call 'erlang':'is_atom'
			  (P) ->
		    %% Line 658
		    case call 'dict':'is_key'
			     (P, Store) of
		      %% Line 659
		      <'true'> when 'true' ->
			  let <_cor3> =
			      %% Line 660
			      apply 'dict_prepend'/3
				  (P, P, Store)
			  in  %% Line 660
			      apply 'split'/3
				  (Ps, _cor3, Rest)
		      %% Line 661
		      <'false'> when 'true' ->
			  %% Line 662
			  apply 'split'/3
			      (Ps, Store, [P|Rest])
		      ( <_cor4> when 'true' ->
			    primop 'match_fail'
				({'case_clause',_cor4})
			-| ['compiler_generated'] )
		    end
		%% Line 664
		<>
		    when try
			  let <_cor5> =
			      call 'erlang':'tuple_size'
				  (P)
			  in  call 'erlang':'>='
				  (_cor5, 1)
		      of <Try> ->
			  Try
		      catch <T,R> ->
			  'false' ->
		    let <Key> =
			%% Line 666
			call 'erlang':'element'
			    (1, P)
		    in  %% Line 667
			case call 'dict':'is_key'
				 (Key, Store) of
			  %% Line 668
			  <'true'> when 'true' ->
			      let <_cor7> =
				  %% Line 669
				  apply 'dict_prepend'/3
				      (Key, P, Store)
			      in  %% Line 669
				  apply 'split'/3
				      (Ps, _cor7, Rest)
			  %% Line 670
			  <'false'> when 'true' ->
			      %% Line 671
			      apply 'split'/3
				  (Ps, Store, [P|Rest])
			  ( <_cor8> when 'true' ->
				primop 'match_fail'
				    ({'case_clause',_cor8})
			    -| ['compiler_generated'] )
			end
		%% Line 673
		<> when 'true' ->
		    %% Line 674
		    apply 'split'/3
			(Ps, Store, [P|Rest])
	      end
	  %% Line 676
	  <[],Store,Rest> when 'true' ->
	      %% Line 677
	      {Store,Rest}
	  ( <_cor11,_cor10,_cor9> when 'true' ->
		( primop 'match_fail'
		      ({'function_clause',_cor11,_cor10,_cor9})
		  -| [{'function_name',{'split',3}}] )
	    -| ['compiler_generated'] )
	end
'dict_prepend'/3 =
    %% Line 679
    fun (_cor2,_cor1,_cor0) ->
	let <_cor3> =
	    %% Line 680
	    call 'dict':'fetch'
		(_cor2, _cor0)
	in  %% Line 680
	    call 'dict':'store'
		(_cor2, [_cor1|_cor3], _cor0)
'module_info'/0 =
    fun () ->
	call 'erlang':'get_module_info'
	    ('proplists')
'module_info'/1 =
    fun (_cor0) ->
	call 'erlang':'get_module_info'
	    ('proplists', _cor0)
end
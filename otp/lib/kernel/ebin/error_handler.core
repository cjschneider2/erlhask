module 'error_handler' ['breakpoint'/3,
			'module_info'/0,
			'module_info'/1,
			'raise_undef_exception'/3,
			'stub_function'/3,
			'undefined_function'/3,
			'undefined_lambda'/3]
    attributes [%% Line 33
		'spec' =
		    %% Line 33
		    [{{'undefined_function',3},[{'type',33,'bounded_fun',[{'type',33,'fun',[{'type',33,'product',[{'var',33,'Module'}|[{'var',33,'Function'}|[{'var',33,'Args'}]]]}|[{'type',34,'any',[]}]]}|[[{'type',35,'constraint',[{'atom',35,'is_subtype'}|[[{'var',35,'Module'}|[{'type',35,'atom',[]}]]]]}|[{'type',36,'constraint',[{'atom',36,'is_subtype'}|[[{'var',36,'Function'}|[{'type',36,'atom',[]}]]]]}|[{'type',37,'constraint',[{'atom',37,'is_subtype'}|[[{'var',37,'Args'}|[{'type',37,'list',[]}]]]]}]]]]]}]}],
		%% Line 54
		'spec' =
		    %% Line 54
		    [{{'undefined_lambda',3},[{'type',54,'bounded_fun',[{'type',54,'fun',[{'type',54,'product',[{'var',54,'Module'}|[{'var',54,'Fun'}|[{'var',54,'Args'}]]]}|[{'type',54,'term',[]}]]}|[[{'type',55,'constraint',[{'atom',55,'is_subtype'}|[[{'var',55,'Module'}|[{'type',55,'atom',[]}]]]]}|[{'type',56,'constraint',[{'atom',56,'is_subtype'}|[[{'var',56,'Fun'}|[{'type',56,'fun',[]}]]]]}|[{'type',57,'constraint',[{'atom',57,'is_subtype'}|[[{'var',57,'Args'}|[{'type',57,'list',[]}]]]]}]]]]]}]}],
		%% Line 71
		'spec' =
		    %% Line 71
		    [{{'breakpoint',3},[{'type',71,'fun',[{'type',71,'product',[{'ann_type',71,[{'var',71,'Module'}|[{'type',71,'atom',[]}]]}|[{'ann_type',71,[{'var',71,'Function'}|[{'type',71,'atom',[]}]]}|[{'ann_type',71,[{'var',71,'Args'}|[{'type',71,'list',[{'var',71,'_'}]}]]}]]]}|[{'type',72,'any',[]}]]}]}],
		%% Line 77
		'spec' =
		    %% Line 77
		    [{{'raise_undef_exception',3},[{'type',77,'bounded_fun',[{'type',77,'fun',[{'type',77,'product',[{'var',77,'Module'}|[{'var',77,'Function'}|[{'var',77,'Args'}]]]}|[{'type',77,'no_return',[]}]]}|[[{'type',78,'constraint',[{'atom',78,'is_subtype'}|[[{'var',78,'Module'}|[{'type',78,'atom',[]}]]]]}|[{'type',79,'constraint',[{'atom',79,'is_subtype'}|[[{'var',79,'Function'}|[{'type',79,'atom',[]}]]]]}|[{'type',80,'constraint',[{'atom',80,'is_subtype'}|[[{'var',80,'Args'}|[{'type',80,'list',[]}]]]]}]]]]]}]}],
		%% Line 93
		'spec' =
		    %% Line 93
		    [{{'crash',2},[{'type',93,'fun',[{'type',93,'product',[{'type',93,'atom',[]}|[{'type',93,'list',[{'type',93,'term',[]}]}]]}|[{'type',93,'no_return',[]}]]}]}],
		%% Line 98
		'spec' =
		    %% Line 98
		    [{{'crash',3},[{'type',98,'fun',[{'type',98,'product',[{'type',98,'atom',[]}|[{'type',98,'atom',[]}|[{'type',98,'union',[{'type',98,'arity',[]}|[{'type',98,'list',[{'type',98,'term',[]}]}]]}]]]}|[{'type',98,'no_return',[]}]]}]}],
		%% Line 103
		'spec' =
		    %% Line 103
		    [{{'crash',1},[{'type',103,'fun',[{'type',103,'product',[{'type',103,'tuple','any'}]}|[{'type',103,'no_return',[]}]]}]}],
		%% Line 133
		'spec' =
		    %% Line 133
		    [{{'stub_function',3},[{'type',133,'fun',[{'type',133,'product',[{'type',133,'atom',[]}|[{'type',133,'atom',[]}|[{'type',133,'list',[{'var',133,'_'}]}]]]}|[{'type',133,'no_return',[]}]]}]}]]
'undefined_function'/3 =
    %% Line 39
    fun (_cor2,_cor1,_cor0) ->
	%% Line 40
	case apply 'ensure_loaded'/1
		 (_cor2) of
	  %% Line 41
	  <{'module',_cor9}>
	      when call 'erlang':'=:='
		    (_cor9,
		     _cor2) ->
	      let <_cor3> =
		  %% Line 42
		  call 'erlang':'length'
		      (_cor0)
	      in  %% Line 42
		  case call 'erlang':'function_exported'
			   (_cor2, _cor1, _cor3) of
		    %% Line 43
		    <'true'> when 'true' ->
			%% Line 44
			call 'erlang':'apply'
			    (_cor2, _cor1, _cor0)
		    %% Line 45
		    <'false'> when 'true' ->
			%% Line 46
			apply 'call_undefined_function_handler'/3
			    (_cor2, _cor1, _cor0)
		    ( <_cor4> when 'true' ->
			  primop 'match_fail'
			      ({'case_clause',_cor4})
		      -| ['compiler_generated'] )
		  end
	  %% Line 48
	  <{'module',_cor10}> when 'true' ->
	      %% Line 49
	      apply 'crash'/3
		  (_cor2, _cor1, _cor0)
	  %% Line 50
	  <_X_Other> when 'true' ->
	      %% Line 51
	      apply 'crash'/3
		  (_cor2, _cor1, _cor0)
	end
'undefined_lambda'/3 =
    %% Line 59
    fun (_cor2,_cor1,_cor0) ->
	%% Line 60
	case apply 'ensure_loaded'/1
		 (_cor2) of
	  %% Line 61
	  <{'module',_cor7}>
	      when call 'erlang':'=:='
		    (_cor7,
		     _cor2) ->
	      %% Line 64
	      call 'erlang':'apply'
		  (_cor1, _cor0)
	  %% Line 65
	  <{'module',_cor8}> when 'true' ->
	      %% Line 66
	      apply 'crash'/2
		  (_cor1, _cor0)
	  %% Line 67
	  <_X_Other> when 'true' ->
	      %% Line 68
	      apply 'crash'/2
		  (_cor1, _cor0)
	end
'breakpoint'/3 =
    %% Line 74
    fun (_cor2,_cor1,_cor0) ->
	let <_cor3> =
	    %% Line 75
	    apply 'int'/0
		()
	in  %% Line 75
	    call _cor3:'eval'
		(_cor2, _cor1, _cor0)
'raise_undef_exception'/3 =
    %% Line 82
    fun (_cor2,_cor1,_cor0) ->
	%% Line 83
	apply 'crash'/1
	    ({_cor2,_cor1,_cor0,[]})
'int'/0 =
    %% Line 88
    fun () ->
	'int'
'crash'/2 =
    %% Line 95
    fun (_cor1,_cor0) ->
	%% Line 96
	apply 'crash'/1
	    ({_cor1,_cor0,[]})
'crash'/3 =
    %% Line 100
    fun (_cor2,_cor1,_cor0) ->
	%% Line 101
	apply 'crash'/1
	    ({_cor2,_cor1,_cor0,[]})
'crash'/1 =
    %% Line 105
    fun (_cor0) ->
	%% Line 106
	try
	    call 'erlang':'error'
		('undef')
	of <_cor1> ->
	    _cor1
	catch <_cor4,_cor3,_cor2> ->
	    case <_cor4,_cor3,_cor2> of
	      %% Line 108
	      <'error','undef',_cor9> when 'true' ->
		  let <_cor5> =
		      %% Line 109
		      call 'erlang':'get_stacktrace'
			  ()
		  in  let <_cor6> =
			  %% Line 109
			  call 'erlang':'tl'
			      (_cor5)
		      in  let <Stk> =
			      %% Line 109
			      [_cor0|_cor6]
			  in  %% Line 110
			      call 'erlang':'raise'
				  ('error', 'undef', Stk)
	      ( <_cor4,_cor3,_cor2> when 'true' ->
		    primop 'raise'
			(_cor2, _cor3)
		-| ['compiler_generated'] )
	    end
'ensure_loaded'/1 =
    %% Line 115
    fun (_cor0) ->
	let <Self> =
	    %% Line 116
	    call 'erlang':'self'
		()
	in  %% Line 117
	    case call 'erlang':'whereis'
		     ('code_server') of
	      %% Line 123
	      <_cor7>
		  when call 'erlang':'=:='
			(_cor7,
			 Self) ->
		  let <_cor2> =
		      %% Line 125
		      call 'erlang':'atom_to_list'
			  (_cor0)
		  in  let <_cor3> =
			  %% Line 125
			  call 'erlang':'++'
			      (_cor2, [39])
		      in  let <Error> =
			      %% Line 124
			      call 'erlang':'++'
				  ([84|[104|[101|[32|[99|[111|[100|[101|[32|[115|[101|[114|[118|[101|[114|[32|[99|[97|[108|[108|[101|[100|[32|[116|[104|[101|[32|[117|[110|[108|[111|[97|[100|[101|[100|[32|[109|[111|[100|[117|[108|[101|[32|[96]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]], _cor3)
			  in  %% Line 126
			      call 'erlang':'halt'
				  (Error)
	      %% Line 127
	      <Pid>
		  when call 'erlang':'is_pid'
			(Pid) ->
		  %% Line 128
		  call 'code':'ensure_loaded'
		      (_cor0)
	      %% Line 129
	      <_cor8> when 'true' ->
		  %% Line 130
		  call 'init':'ensure_loaded'
		      (_cor0)
	    end
'stub_function'/3 =
    %% Line 135
    fun (_cor2,_cor1,_cor0) ->
	%% Line 136
	call 'erlang':'exit'
	    ({'undef',[{_cor2,_cor1,_cor0,[]}|[]]})
'call_undefined_function_handler'/3 =
    %% Line 138
    fun (_cor2,_cor1,_cor0) ->
	%% Line 140
	case call 'erlang':'function_exported'
		 (_cor2, '$handle_undefined_function', 2) of
	  %% Line 141
	  <'false'> when 'true' ->
	      %% Line 142
	      apply 'crash'/3
		  (_cor2, _cor1, _cor0)
	  %% Line 143
	  <'true'> when 'true' ->
	      %% Line 144
	      call _cor2:'$handle_undefined_function'
		  (_cor1, _cor0)
	  ( <_cor4> when 'true' ->
		primop 'match_fail'
		    ({'case_clause',_cor4})
	    -| ['compiler_generated'] )
	end
'module_info'/0 =
    fun () ->
	call 'erlang':'get_module_info'
	    ('error_handler')
'module_info'/1 =
    fun (_cor0) ->
	call 'erlang':'get_module_info'
	    ('error_handler', _cor0)
end